## 모델 뷰 컨트롤러 패턴 개요 (Model-View-Controller Pattern Intro)
**복합 패턴 (Compound Pattern)**
- 두 개 이상의 패턴을 결합하여 반복적이거나 일반적인 문제를 해결하는 패턴
- MVC 패턴은 다음 패턴들을 사용
	- 전략 패턴(Strategy Pattern)
	- 관찰자 패턴(Observer Pattern)
	- 전체-부분 패턴(Composite Pattern)

**MVC 패턴의 구성 요소**
*Model*
- 데이터와 비즈니스 로직을 담당 - 어플리케이션 객체
- 데이터의 변경을 통보받아 View에 변경 사항을 전달

*View*
- 사용자에게 데이터를 시각적으로 보여주는 역할
- Model의 데이터를 참조하여 화면을 구성

*Controller*
- 사용자의 입력을 받아 Model에 명령을 전달
- Model의 데이터를 변경하고, 변경 사항을 View에 전달

## MVC 패턴을 사용하는 이유 (Why Use MVC Pattern)
동일한 엔터프라이즈 데이터는 서로 다른 뷰로 표현될 때 접근 가능해야 한다.
- 예) 엔터프라이즈 데이터를 웹 브라우저, 모바일 앱, 데스크톱 앱 등 다양한 뷰로 표현
- 서로 다른 상호작용을 통해 업데이트 가능해야 한다
- 여러 종류의 뷰와 상호작용을 지원해도 엔터프라이즈 어플리케이션의 핵심 기능 컴포넌트에 영향을 주지 않아야 한다.

## MVC 패턴의 역할 (Roles of MVC Pattern)
**책임 분리 (Separating of responsibilities)**
- 핵심 비즈니스 모델 기능을 프레젠테이션 및 제어 로직에서 분리
- 여러 뷰가 동일한 모델을 공유할 수 있음
- 여러 클라이언트 지원, 테스트 및 유지보수 용이

**모델 (Model)**
- 데이터와 비즈니스 로직을 담당

**뷰 (View)**
- 사용자에게 데이터를 시각적으로 보여주는 역할
- 모델을 통해 데이터를 가져와 화면을 구성

**컨트롤러 (Controller)**
- 뷰와의 상호작용을 모델이 수행할 작업으로 변환

## MVC에서의 패턴 (Patterns in MVC)
**관찰자 패턴 (Observer Pattern)**: 뷰와 모델의 분리
- 모델의 *상태 변경*을 관심이 있는 다수의 객체에 *통보*할 수 있도록 분리

**전체-부분 패턴 (Composite Pattern)**: 중첩된 뷰 위젯
- 기본 객체와 복합 객체를 동일한 인터페이스를 가진 객체로 그룹화

**전략 패턴 (Strategy Pattern)**: 뷰가 제스처 해석을 컨트롤러에 위임
- 다양한 해석을 지원하기 위해 컨트롤러를 교체할 수 있다.

*Factory* 패턴과 *Decorator* 패턴도 사용될 수 있다.

## Java에서의 관찰자 패턴 예시 (Example on Observer Pattern in Java)
<Img src="/posts/240617-200651.png" width={400}/>

**Observable (발행자) 측**
- 알림을 보내기 위해
	- `SetChanged()` 호출
	- `notifyObservers()` 또는 `notifyObservers(Object arg)` 호출

**Observer (구독자) 측**
- 옵저버가 되기 위해
	- `java.util.Observer` 인터페이스 구현
- 구독하기 위해
	- 모든 Observable 객체에서 `addObserver()` 호출
- 구독 해지하기 위해
	- `deleteObserver()` 호출
- 업데이트를 받기 위해
	- `update(Observable o, Object arg)` 구현

```java title="예시 코드"
import java.util.Observable;
import java.util.Observer;

// Observable 클래스 (발행자)
class NewsAgency extends Observable {
    private String news;

    public void setNews(String news) {
        this.news = news;
        setChanged();
        notifyObservers(news);
    }

    public String getNews() {
        return news;
    }
}

// Observer 클래스 (구독자)
class NewsChannel implements Observer {
    private String news;

    @Override
    public void update(Observable o, Object arg) {
        this.news = (String) arg;
        System.out.println("News updated: " + news);
    }
}

// 메인 클래스
public class Main {
    public static void main(String[] args) {
        NewsAgency newsAgency = new NewsAgency();
        NewsChannel newsChannel = new NewsChannel();

        // 구독
        newsAgency.addObserver(newsChannel);

        // 뉴스 업데이트
        newsAgency.setNews("Breaking News!");
    }
}
```

## 정리 (Summary)
**MVC 패턴은 옵저버, 전략, 그리고 컴포지트 패턴으로 구성된다.**
- 모델(Model): *옵저버* 패턴을 사용하여 옵저버들을 업데이트하지만, 그들과 분리된 상태를 유지한다.
- 다른 패턴들: *전략* 패턴과 *컴포지트* 패턴

**중요한 결정사항**
- UI 변경이 비-UI 모듈의 변경을 유발해서는 안 된다.
	→ 비-UI 모듈은 UI 모듈에 의존해서는 안 된다.