## 설계 클래스 다이어그램 (Design Class Diagram)
동일한 UML 클래스 다이어그램을 여러 관점에서 사용할 수 있음.
- 개념적 관점: **도메인 모델** (Domain Model)
	<Img src="/posts/240617-223137.png" width={300}/>
- 설계 관점: **설계 클래스 다이어그램** (Design Class Diagram)
	<Img src="/posts/240617-223143.png" width={300}/>

## 다른 관점에서의 연관 관계 (Association in Different Perspectives)
**도메인 모델**:
- 연관 관계 이름을 표시하지만 도메인 모델은 소프트웨어 관점이 아니므로 탐색 화살표는 피함
	<Img src="/posts/240617-223346.png" width={300}/>
	- 연관 관계 이름은 도메인 모델을 그릴 때 흔히 생략됨 (합법이긴 하지만)
	- 소프트웨어 관점의 클래스 다이어그램을 사용할 때는 DCD에서 연관 관계 이름을 포함

**DCD**:
- UML 명세를 따름
	<Img src="/posts/240617-223355.png" width={300}/>

## 키워드 (Keywords)
모델 요소를 범주화 하기 위한 키워드 사용
<Img src="/posts/240617-223758.png" width={200}/>
ex.유스케이스 다이어그램에서 `«actor»` 키워드 사용: 사람 스틱 피겨 배우 아이콘을 클래스 상자로 대체하여 컴퓨터 시스템 또는 로봇 배우 모델링

| Keyword | Meaning | Example Usage |
| --- | --- | --- |
|«actor» |분류자가 액터임을 나타냄|클래스 다이어그램에서 분류자 이름 위에 표시|
|«interface» |분류자가 인터페이스임을 나타냄|클래스 다이어그램에서 분류자 이름 위에 표시|
|\{abstract\} |추상 요소; 인스턴스화할 수 없음|클래스 다이어그램에서 분류자 이름이나 연산 이름 뒤에 표시|
|\{ordered\} |객체 집합이 일정한 순서를 가짐|클래스 다이어그램에서 연관 끝에 표시|

## 스테레오타입, 프로파일, 태그 (Stereotype, Profile, Tag)
**스테레오타입**: 기존 모델링 개념의 세분화를 나타냄
- UML 스테레오타입은 UML 명세에 정의되어 있으며 키워드가 아님
- UML에서 확장 매커니즘 제공

**프로파일**: 스테레오타입, *태그*, 제약 조건의 집합

## 상호작용 다이어그램과 클래스 다이어그램 간의 관계 (Relationship between Interaction Diagrams and Class Diagrams)
상호작용 다이어그램으로부터 클래스 다이어그램의 정의를 생성할 수 있다.
- **상호작용 다이어그램을 그리면, 클래스와 메소드의 집합이 나타난다.**
- 예를 들어, `makePayment` 시퀀스 다이어그램으로 시작하면, 클래스 다이어그램에서 `Register`와 `Sale` 클래스 정의를 도출할 수 있다.
	<Img src="/posts/240617-224513.png" width={500}/>
	메시지 상호작용 다이어그램은 클래스 다이어그램에서 연산을 나타낸다.
	상호작용 다이어그램에서 식별된 클래스는 클래스 다이어그램에 선언된다.

## 상호작용 다이어그램에서 코드 도출 예시 (Example of Code Derivation from Interaction Diagram)
<Img src="/posts/240617-224738.png" width={400}/>
- `A`는 `X` 객체에 `doA()` 메시지를 보낸다.
- `X` 객체는 `Y` 객체를 생성하고(`create()`), `Y` 객체는 `X` 객체에 `doB(this)` 메시지를 보낸다.
- `X` 객체는 다시 `Y` 객체를 생성하고(`create()`), 새로 생성된 `Y` 객체에 `doD(y2)` 메시지를 보낸다.
- 마지막으로, `X` 객체는 `Y` 객체에 `doE()` 메시지를 보낸다.

```java title="예시 코드" {numberLines: true}
public class X {
    public void doA() {
        Y y1 = new Y();
        boolean flag = y1.doB(this);
        Y y2 = new Y();
        this.doD(y2);
        y2.doE();
    }
    public void doD(Y y) {
        // doD 메소드의 구현
    }
}

public class Y {
    public boolean doB(X x) {
        Y y2 = new Y();
        x.doD(y2);
        // ...
        return true; // 예시 값
    }
    public void doE() {
        // doE 메소드의 구현
    }
}

public class Main {
    public static void main(String[] args) {
        X x = new X();
        x.doA();
    }
}
```