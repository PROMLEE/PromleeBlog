## 자료구조의 분류
- 선형구조 (Linear Structure)
	- 배열 (Array)
	- 선형 리스트 (Linear List)
		- 연속 리스트 (Contiguous List)
		- 연결 리스트 (Linked List)
	- 스택 (Stack)
	- 큐 (Queue)
	- 데크 (Deque)
- 비선형구조 (Non-Linear Structure)
	- 트리 (Tree)
	- 그래프 (Graph)

## 선형 구조 (Linear Structure)
### 선형 리스트 (Linear List)
연속 리스트
- 연속 리스트는 배열과 같이 연속되는 메모리 공간에 데이터를 저장하는 자료구조이다.
- 데이터의 삽입, 삭제 연산시 자료의 이동이 필요하다
- 메모리 효율이 좋다
연결 리스트
- 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료이다
- 데이터의 삽입, 삭제 연산시 자료의 이동이 필요없다
- 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다

### 스택 (Stack)
> 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조

- 후입선출 (Last In First Out, LIFO) 구조
- 응용 분야
	- 함수 호출 순서 제어
	- 인터럽트 처리
	- 수식 계산 및 수식 표기법
	- 컴파일러를 이용한 언어 번역
	- 서브루틴 호출 및 복귀 주소 저장
모든 공간이 채워져 있는 상태에서 삽입 연산을 수행하면 *스택 오버플로우*가 발생한다
모든 공간이 비워져 있는 상태에서 삭제 연산을 수행하면 *스택 언더플로우*가 발생한다
![240507-143507w](/posts/240507-143507.png)
[이미지 출처](https://www.geeksforgeeks.org/stack-data-structure/)

### 큐 (Queue)
> 리스트의 한쪽에서 삽입 작업이 이루어지고 다른 한쪽에서 삭제 작업이 이루어지는 자료 구조

- 선입선출 (First In First Out, FIFO) 구조
- 시작과 끝을 나타내는 두 개의 포인터가 존재
![240507-143759w](/posts/240507-143759.png)
[이미지 출처](https://www.geeksforgeeks.org/queue-data-structure/)


## 비선형 구조 (Non-Linear Structure)
### 방향/무방향 그래프의 최대 간선 수
- 방향 그래프의 최대 간선 수: n(n-1)
- 무방향 그래프의 최대 간선 수: n(n-1)/2
### 트리의 개요
트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태
- 루트(Root): 트리의 시작 정점
- 부모(Parent): 노드에서 가리키는 상위 노드
- 자식(Child): 노드를 가리키는 하위 노드
- 형제(Sibling): 같은 부모를 가지는 노드
- 차수(Degree): 노드에 연결된 자식의 수
- 레벨(Level): 루트로부터의 깊이
- 높이(Height): 트리의 최대 레벨

### 트리의 운행법
- 전위 운행법 (Preorder Traversal)
	- 루트 -> 왼쪽 자식 -> 오른쪽 자식
- 중위 운행법 (Inorder Traversal)
	- 왼쪽 자식 -> 루트 -> 오른쪽 자식
- 후위 운행법 (Postorder Traversal)
	- 왼쪽 자식 -> 오른쪽 자식 -> 루트

#### 수식 표기법
- 전위 표기법 (Prefix Notation)
	- 연산자를 먼저 표기
	- +AB
- 중위 표기법 (Infix Notation)
	- 연산자를 중간에 표기
	- A+B
- 후위 표기법 (Postfix Notation)
	- 연산자를 나중에 표기
	- AB+

## 정렬
### 삽입 정렬 (Insertion Sort)
> 삽입 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 정렬된 부분에 삽입하는 방식으로 정렬하는 알고리즘이다

![240507-144655w](/posts/240507-144655.png)
[이미지 출처](https://dev.to/harshanalk/data-sorting-1k86)

### 선택 정렬 (Selection Sort)
> 선택 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분에서 가장 작은 원소를 선택하여 정렬된 부분의 마지막 원소와 교환하는 방식으로 정렬하는 알고리즘이다

![240507-144635](/posts/240507-144635.png)
[이미지 출처](https://dev.to/harshanalk/data-sorting-1k86)

### 버블 정렬 (Bubble Sort)
> 버블 정렬은 인접한 두 원소를 비교하여 정렬하는 방식으로 정렬하는 알고리즘이다

### 퀵 정렬 (Quick Sort)
> 퀵 정렬은 분할 정복 방법을 사용하여 배열을 정렬하는 알고리즘이다

하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 이동시킨다
평군 수행 시간 복잡도는 `O(n log n)`이다
최악의 경우 수행 시간 복잡도는 `O(n^2)`이다
![240507-144832](/posts/240507-144832.png)
[이미지 출처](https://dev.to/harshanalk/data-sorting-1k86)

### 힙 정렬 (Heap Sort)
> 힙 정렬은 힙 자료구조를 이용하여 정렬하는 알고리즘이다

### 2-Way 합병 정렬 (Merge Sort)
> 2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다

평균과 최악의 경우 수행 시간 복잡도는 `O(n log n)`이다

![240507-144930](/posts/240507-144930.png)
[이미지 출처](https://www.upgrad.com/blog/sorting-in-data-structure-with-examples/)

## 검색 알고리즘 (Search Algorithm)
### 이분 검색 (Binary Search)
> 이분 검색은 정렬된 배열에서 중간 값을 기준으로 검색하는 방식으로 검색하는 알고리즘이다

전체 파일을 두 개의 서브파일로 분리해 가면서 Key 리코드를 검색하는 방식
- 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어듦으로 탐색 효율이 좋고 탐색 시간이 적게 소요됨
- 중간 레코드 번호 $M=(F+L)/2$로 계산
	- F: 검색 대상의 첫 번째 레코드 번호, L: 검색 대상의 마지막 레코드 번호

### 해싱 함수 (Hashing Function)
> 해싱 함수는 키를 해시 테이블의 주소로 변환하는 함수이다

- **폴딩법(Folding)**: 레코드 키(K)를 여러 부분으로 나눈 후, 이를 더한 값을 홈 주소로 삼는 방식
	- $H(K) = (K_1 + K_2 + K_3 + \cdots + K_n) \mod M$
- **제산법(Division)**: 레코드 키(K)를 해시표(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나는 나머지를 홈 주소로 삼는 방식
	- $H(K) = K \mod M$
- **기수 변환법(Radix)**: 레코드 키(K)를 해시 테이블의 크기(M)에 대한 진수로 변환한 후, 이를 홈 주소로 삼는 방식
	- $H(K) = K_{10} \mod M$
- **숫자 분석법(Digit Analysis, 계수 분석법)**: 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 추출하여 홈 주소로 삼는 방식
- 제곱법(Mid-Square): 레코드 키(K)를 제곱한 후, 그 결과의 중간 부분을 홈 주소로 삼는 방식
	- $H(K) = (K^2) \mod M$
- 대수적 코딩법(Algebraic Coding): 레코드 키(K)를 다항식으로 변환한 후, 이를 홈 주소로 삼는 방식
	- $H(K) = aK^2 + bK + c$
- 무작위법(Random): 레코드 키(K)를 무작위로 선택하여 홈 주소로 삼는 방식

## 빌드 자동화 도구
> 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리, 컴파일 등의 작업 수행

| 도구 | 설명 |
|---|---|
| **Ant(Another Neat Tool)** | 자바 프로젝트의 공식적 빌드 자동화 도구(XML 기반)<br/>표준이 없어 개발자가 모든 것을 정의함, 스크립트 재사용 어려움 |
| **Maven** | 예외 사항만을 기록하는 표준이 있음(Ant의 대안)<br/>컴파일과 빌드 동시 수행 가능, 의존성 설정 후 라이브러리 관리 |
| **Gradle** | Groovy 스크립트를 사용하는 빌드 도구<br/>의존성을 활용하며 빌드 캐시 기능 지원 -> 속도 향상<br/>실행할 명령을 모아 태스크로 만든 후 태스크 단위 실행 |
| **Jenkins** | JAVA 기반 오픈소스 빌드 자동화 도구<br/>서블릿 컨테이너에서 실행<br/>형상 도구 관리와 연동 가능(Git, SVN) |

## 디지털 저작권 관리 (DRM, Digital Rights Management)
> 디지털 저작물의 저작권을 보호하고 관리하는 기술

- 콘텐츠 제공자/분배자/소비자/패키저(배포 가능한 암호화)
- *클리어링 하우스*(Clearing House) : 사용 권한, 라이선스 발급, 결제 관리
- *DRM 컨트롤러*: 배포된 콘텐츠의 이용 권한 통제
- *보안 컨테이너*: 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치
-> 기술 요소: 암호화/키 관리/식별 기술/저작권 표현/암호화 파일 생성/정책 관리/크랙 방지/인증

## 소프트웨어 형상 관리 (Software Configuration Management, SCM)
> 소프트웨어 개발 과정에서 발생하는 변경 사항을 체계적으로 관리하는 활동 -> 개발 전체 단계 적용

- 중요성: 변겨사항 추적/통제, 무절제한 변경 방지, 개발 진행 이력 확인
- 형상 관리 역할: 배포본 관리 용이, 불필요한 소스 수정 제한, 여러 개발자 동시 개발

| 단계 | 활동 |
|---|---|
| **형상 식별** | 관리 대상에 이름/번호 부여 후 계층 구조로 구분 → 수정/추적 용이 |
| **형상 제어** | 식별된 형상 항목에 대한 변경 요구 검토(기준선 반영) |
| **형상 감사** | 기준선(Base Line)의 무결성 평가를 위해 확인/검증/검열 과정 진행 |
| **형상 기록** | 형상 식별/통제/감사 작업 결과를 기록/관리하고 보고서 작성 |
- 형상 관리 도구: CVS, SVN, Git
- 제품 SW의 형상 관리 역할: 배포본 관리 유용/ 소스 수정 제한, 동일 프로젝트에 대해 여러 개발자 참여 후 동시 개발 가능

## 소프트웨어 버전 등록 용어
| 용어 | 설명 |
|---|---|
| **저장소(Repository)** | 최신 버전 및 변경 내역 관련 정보 저장소 |
| **가져오기(Import)** | 버전 관리 미진행 상태의 초기 저장소에 처음으로 파일을 복사 |
| **체크아웃(Checkout)** | 프로그램 수정을 위해 저장소에서 파일을 받아옴 |
| **체크인(Checkin)** | 체크아웃한 파일 수정 후 저장소에 새로운 버전으로 파일 갱신 |
| **커밋(Commit)** | 체크인 시 이전 갱신된 내용이 있는 경우 conflict를 알린 후 Diff 도구를 이용해 수정 후 갱신 완료 |
| **동기화(Update)** | 저장소의 변경 사항을 로컬에 반영하는 작업 |

## 소프트웨어 버전 관리 도구
| 도구 | 설명 |
|---|---|
| **공유폴더** | 파일 공유를 통한 로컬에서의 버전 관리<br/>ex) SCCS, *RCS*(Revision Control System), PVCS, QVCS |
| **클라이언트/서버** | 중앙 서버에 저장소를 두고 클라이언트가 서버에 접속해 파일 관리<br/>ex) CVS, *SVN*(Subversion), Perforce, ClearCase |
| **분산 저장소** | 로컬 저장소를 갖고 중앙 서버와 연결해 파일 관리<br/>ex) *Git*, Mercurial, Bazaar |
| **SVN(Subversion)** | CVS의 개선 버전<br/>커밋 할 때마다 리비전 1씩 증가<br/>CVS의 한계인 *파일이나 디렉터리의 이름 변경, 이동 가능* |
| **Git** | 원격 저장소: 여러 사람들이 협업을 위해 버전을 공동 관리하는 장소<br/>로컬 저장소: 개발자들이 본인의 실제 개발을 진행하는 장소<br/>브랜치 이용 시 기존 버전 관리 틀에 영향없이 다양한 기능 테스트 가능, 파일의 변화를 SnapShot으로 저장 |

## 소스 코드 품질분석 도구
- 정적 분석 도구: pmd(코드 결함), cppcheck(C/C++), checkstyle(Java), SonarQube, FindBugs, corbertura, ccm
- 동적 분석 도구: Valance, Valgrind, Avalanche

## EAI (Enterprise Application Integration)
> 기업 내 각종 앱/플랫폼 간 정보 전달/연계/통합 등 상호작용 연동하는 모듈 연계 방식

| 방식 | 설명 |
|---|---|
| **포인트-투-포인트(Point-to-Point)** | 데이터 간 포인트-포인트 개별 연결 → 변경 및 재사용 어려움 |
| **허브&스포크(Hub&Spoke)** | 중앙 집중식 허브를 통해 각 시스템 연결 → 확장/유지보수에 유리하나, 중앙 허브 장애 발생 시 전체 시스템에 영향 |
| **메시지 버스(Message Bus)** | 앱 사이에 미들웨어를 두고 처리/확장성 및 대용량 처리 가능 |
| **Hybrid** | 허브-스포크, 메시지 버스 방식 혼합 → 데이터 병목 현상 최소 |

## 어플리케이션 테스트 기본 원리
- 테스트는 기본적으로 결함이 존재함을 밝히는 것(결함이 없다고 증명하는 것은 불가)
- 결함 집중: *파레토*(Pareto) 법칙에 따라 80\% 결함은 20\% 모듈에 존재
- *살충제 패러독스*: 동일한 테스트 케이스에 의한 반복 테스트는 새로운 버그 발견 X
- 오류-부재의 궤변: 결함이 없다 해도 요구사항 미충족시 품질 저하
- Brooks의 법칙: 지연되는 프로젝트에 인력 추가 투입 시 더 지연됨

## 어플리케이션 테스트 분류
1. 프로그램 실행 여부
	| 분류 | 설명 |
	|---|---|
	| **정적 테스트(Static Test)** | 소스 코드 분석을 통해 테스트<br/>ex) 워크 스루, 인스펙션, 코드 검사 |
	| **동적 테스트(Dynamic Test)** | 프로그램 실행을 통해 테스트<br/>ex) 화이트/블랙박스 테스트 |
2. 테스트 기반
	| 분류 | 설명 |
	|---|---|
	| **명세 기반** | 사용자의 요구사항 명세서를 기반으로 테스트<br/>ex)동등 분할/경계값 분석(블랙박스)|
	| **구조 기반** | 소프트웨어 구조를 기반으로 테스트<br/>ex)구문 기반/결정 기반/조건 기반(화이트박스)|
	| **경험 기반** | 테스터의 경험을 기반으로 테스트<br/>ex)에러 추정, 체크리스트, 탐색적 테스팅 |	
3. 시각(관점) 기반
	| 분류 | 설명 |
	|---|---|
	| **검증(Validation)** | *개발자*의 시각에서 제품의 생산성 과정 테스트<br/>ex)단위/통합/시스템 테스트 |
	| **확인(Verification)** | *사용자*의 시각에서 생산된 제품의 결과 테스트<br/>ex)인수 테스트 (알파/베타) |
4. 목적 기반
	| 분류 | 설명 |
	|---|---|
	| **회복(Recovery)** | 시스템에 인위적 결함 부여 후 정상으로 회복되는 과정 확인 |
	| **안전(Security)** | 외부 불법 침입으로부터 시스템을 보호할 수 있는지 확인 |
	| **강도(Stress)** | 과부하 시 SW 정상 구동 여부 확인 |
	| **성능(Performance)** | 실시간 성능 및 전체적인 효율성 진단(응답시간, 업무 처리량) |
	| **구조(Structural)** | SW 내부 논리적 경로 및 소스 코드 복잡도 평가 |
	| **회귀(Regression)** | SW 내 변경 또는 수정된 코드에 새로운 결함이 없음을 확인 |
	| **병행(Concurrent)** | 변경 및 기존 SW에 동일한 데이터 입력 후 결과 비교 |

## 화이트박스 테스트 (White Box Test)
- 모듈 안의 내용(작동) 직접 볼 수 있으며, 내부의 논리적인 *모든 경로 테스트*
- 소스 코드의 모든 문장을 한 번 이상 수행/ *논리적 경로 점검* (선택,반복 수행)
- 테스트 데이터 선택을 위해 *검증 기준*(Coverage)을 정함
	→ *기초 경로 검사*(Base Path Test): 대표적 화이트박스 테스트 기법(동적 테스트) / 싸이클 최대 한번
	→ 제어 구조 검사(Control Structure Test): *조건 검사*, *루프 검사*, *자료 흐름 검사*

## 블랙박스 테스트 (Black Box Test)
- 모듈 내부의 내용 알 수 없음 / 소프트웨어 인터페이스에서 실시되는 테스트
- SW 각 기능이 완전히 작동되는 것을 입증하는 테스트로 *기능 테스트*라고 함
	→ **동치 분할 검사/ 경계값 분석/ 원인-효과 그래프 검사/ 비교 검사/ 오류 예측 검사**

## 개발 단계에 따른 어플리케이션 테스트
1. **단위 테스트(Unit Test)**
	- 개별 모듈(컴포넌트)이 정상적으로 작동하는지 확인
	- 주로 *구조 기반 테스트* 진행 / 기능성 테스트 최우선
2. **통합 테스트(Integration Test)**
	- 단위 테스트 후 모듈을 통합하는 과정에서 발생하는 오류 확인
	- **상향식 통합 테스트**: 모듈을 하나씩 통합 / *스텁*(Stub): 모듈의 기능을 단순히 수행하는 도구(시험용 모듈)
	- **하향식 통합 테스트**: 모듈을 하나씩 분리 / 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 *클러스터*(Cluster)와 *드라이버*(Driver)를 사용, 스텁은 미사용
3. **시스템 테스트(System Test)**
	- 개발된 SW의 컴퓨터 시스템 내 작동여부를 점검
	- 실제 사용 환경과 유사한 테스트 환경 → *기능적*(블랙박스) 및 *비기능적*(화이트박스) 테스트 구분
4. **인수 테스트(Acceptance Test)**
	- 사용자가 요구사항을 만족하는지 확인
	- **알파 테스트**: 통제된 환경에서 사용자가 개발자와 함께 확인
	- **베타 테스트**: 통제되지 않은 환경에서 *개발자 없이* 여러 명의 사용자가 검증

## 테스트 케이스 (Test Case)
- 개발된 SW가 사용자의 요구사항을 잘 반영했는지 확인하기 위해 설계된 *입력값*(데이터), *실행 조건*, *기대 결과* 등로 구성된 테스트 항목에 대한 명세서
	*테스트의 목표/방향 결정* 후 테스트 케이스 작성

## 테스트 시나리오 (Test Scenario)
> 테스트 케이스를 적용하는 구체적인 절차를 명세한 문서

유의사항: 시스템/모듈/항목별 여러 개의 시나리오로 분리해 작성/사용자의 요구사항과 설계 문서 등을 토대로 작성

## 테스트 오라클 (Test Oracle)
> 테스트 결과가 올바른지 판단하기 위한 기준

- 특성: 제한된 검증/수학적 기법/자동화 기능
- 종류: 참 (모든 오류 검출) / 샘플링 / 휴리스틱 (추정) / 일관성(수행 전/후 비교)

## 테스트 하네스 (Test Harness)
| 용어 | 설명 |
|---|---|
| **테스트 드라이버(Test Driver)** | 시험 대상의 하위 모듈 호출 / 모듈 테스트 수행 후의 결과 도출<br/>→ 상향식 통합 테스트에서 사용 |
| **테스트 스텁(Test Stub)** | 제어 모듈이 호출하는 하위 모듈의 역할 단순 수행<br/>→ 하향식 테스트에서 사용|
| **테스트 슈트(Test Suite)** | 시스템에 사용되는 테스트 케이스의 집합(컴포넌트/모듈) |
| **테스트 케이스** | 사용자의 요구사항 준수 여부 확인 목적 테스트 항목 명세서 <br/> → 입력값, 실행조건, 기대결과 |
| **테스트 스크립트** | 자동화된 테스트 실행 절차에 대한 명세서 |
| **목 오브젝트(Mock Object)** | 사용자의 행위 조건부 입력 시 계획된 행위를 수행하는 객체 |

## 데이터 통신을 이용한 인터페이스 구현
- 애플리케이션 영역에서 데이터 포맷을 인터페이스 대상으로 전송

	이를 수신 측에서 파싱(Parsing)후 해석하는 방식
- JSON(JavaScript Object Notation): *속성-값 쌍*으로 이루어진 데이터 오브젝트를 전달하기 위해 사용하는 개방형 표준 포맷 → *AJAX*(javascript에서 사용한 비동기 통신기술)에서 많이 사용 / XML을 대체하는 주요 데이터 포맷
- XML(eXtensible Markup Language): HTML 문법의 비호환성과 SGML의 복잡성 해결

## 인터페이스 구현 검증 도구들
| 도구 | 설명 |
|---|---|
| **xUnit** | Java, C++, Net등 다양한 언어를 지원하는 단위 테스트 프레임워크 |
| **STAF** | *서비스 호출*, *컴포넌트 재사용* 등 다양한 환경을 지원 |
| **Fitness** | *웹 기반* 테스트케이스 설계/실행/결과 확인 지원 |
| **NTAF** | STAF의 재사용성 및 확장성 + Fitness의 협업 기능 통합(현재는 폐기) |
| **Selenium** | 다양한 브라우저 및 개발 언어를 지원하는 *웹 애플리케이션* 테스트 |
| **watir** | Ruby 기반 애플리케이션 테스트 프레임워크 |

## 인스펙션 (Inspection)
- 계획 → 사전교육 → 준비 → 인스펙션 회의 → 수정 →  후속조치

	$\;\;\uparrow←←←←←←←←←←←←←←←←←←←←←←←←←←←←\downarrow$

## 리팩토링 (Refactoring)
> 겉으로 보이는 동작 변화 없이 내부 구조 변경 (SW 쉽게 이해, 적은 비용으로 수정 가능하게)

## SW 구현 단계
- 코딩 작업 계획 → 코딩 → 컴파일 → 코드 테스트

## 제품 SW 패키징 시 고려사항
- 보안/사용자 편의성/암호화 알고리즘/다기종 연동 고려

## 인터페이스 보안을 위한 네트워크 영역에 적용될 수 있는 Solution
- IPSec, SSL, S-HTTP

# 기출 오답 정리
## 2020년 06년 06월
#### 23. 소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야 할 항목으로 거리가 먼 것은?
1.	정확성
2.	무결성
3.	사용성
4.	간결성

<div className="text-black">답: 4</div>


#### 24. 인터페이스 구현 검증도구 중 아래에서 설명하는 것은?
- 서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
- 각 테스트 대상 분산 환경에 데몬을 사용하여 테스트 대상 프로그램을 통해 테스트를 수행하고, 통합하여 자동화하는 검증 도구

1.	xUnit
2.	STAF
3.	Fitness
4.	RubyNode

<div className="text-black">답: 2</div>
[링크](#인터페이스-구현-검증-도구들)

#### 29.	반정규화(Denormalization) 유형중 중복 테이블을 추가하는 방법에 해당하지 않는 것은?

1.	빌드 테이블의 추가
2.	집계 테이블의 추가
3.	진행 테이블의 추가
4.	특정 부분만을 포함하는 테이블의 추가

<div className="text-black">답: 1</div>
(집)계 테이블 추가 - sum,avg 등의 계산 미리 수행
(중)복 테이블 추가 - 서버 분리 또는 업무 구별
(이)력 테이블 추가 - 레코드 중복 저장
(부)분 테이블 추가 - 접근 시도가 많은 자료만 모아두기
(진)행 테이블 추가 - A에 접근하기위해 다수의 테이블을 거칠 경우 간소화

#### 31.	다음 트리의 차수(degree)와 단말 노드(terminal node)의 수는?
![240508-172437w](/posts/240508-172437.png)
1.	차수: 4, 단말 노드: 4
2.	차수: 2, 단말 노드: 4
3.	차수: 4, 단말 노드: 8
4.	차수: 2, 단말 노드: 8

<div className="text-black">답: 2</div>
트리의 차수: 노드가 가질 수 있는 자식 노드의 최대 개수

#### 33.	소프트 웨어 테스트에서 오류의 80\%는 전체 모듈의 20\% 내에서 발견된다는 법칙은?

1.	Brooks의 법칙
2.	Boehm의 법칙
3.	Pareto의 법칙
4.	Jackson의 법칙

<div className="text-black">답: 3</div>
[링크](#어플리케이션-테스트-기본-원리)

#### 36.	소스코드 품질분석 도구 중 정적분석 도구가 아닌 것은?

1.	pmd
2.	cppcheck
3.	valMeter
4.	checkstyle

<div className="text-black">답: 3</div>
[링크](#소스-코드-품질분석-도구)

#### 38.	하향식 통합에 있어서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈을 무엇이라고 하는가?

1.	Stub
2.	Driver
3.	Procedure
4.	Function

<div className="text-black">답: 1</div>
[링크](#테스트-하네스-Test-Harness)

#### 40.	외계인코드(Alien Code)에 대한 설명으로 옳은 것은?

1.	프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다.
2.	아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다.
3.	오류가 없어 디버깅 과정이 필요 없는 프로그램을 의미한다.
4.	사용자가 직접 작성한 프로그램을 의미한다.

<div className="text-black">답: 2</div>
