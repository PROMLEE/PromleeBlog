---
title: "신뢰성 있는 데이터 전송: TCP"
title_num: 
subtitle: 
subtitle_num: 
desc: 전송 계층의 신뢰성 있는 프로토콜 TCP에 대하여 공부한다
lock: true
tags: []
date: 2024-06-15
lastmod: 
thumbnail: 
---

# 3.5.1 연결 지향 전송: TCP (Connection-Oriented Transport: TCP)
## TCP 개요
- **연결 지향적**(Connection-Oriented)
	- 악수(handshake, 제어 메시지 교환)은 데이터 교환 전 송수신자의 상태/매개변수를 초기화함
	- 논리적인 종단 간 연결이며, 전화 회선처럼 실제 회로는 아님
		- 네트워크 내부에 상태/연결 정보 없음
- **일대일 통신**(Point-to-Point)
	- 한 송신자, 한 수신자
- **전이중 데이터**(Full-Duplex Data)
	- 같은 연결에서 양방향 데이터 흐름
- **흐름 제어**(Flow Control)
	- 수신자가 송신자의 속도에 맞춰 데이터를 받을 수 있도록 함
	- 송신자가 수신자를 압도하지 않음
- **신뢰할 수 있는, 순서대로 정렬된 바이트 스트림** (Reliable, In-Order Byte Stream)
	- 메시지 경계가 없다
	- 메시지를 분할하여 *TCP 세그먼트*를 사용하여 전송
		- MSS(Maximum Segment Size): 한 번에 전송할 수 있는 최대 데이터 크기
- **파이프라인 방식** (Pipelined)
	- TCP 혼잡 및 흐름 제어가 윈도우 크기 결정
	= *min(flow control, congestion control)* -> 동적, 적응적(dynamic, adaptive)

#### 정리 (TCP 개요)
- 연결 지향적, 일대일 통신, 전이중 데이터, 흐름 제어, 신뢰할 수 있는, 순서대로 정렬된 바이트 스트림, 파이프라인 방식의 통신 프로토콜

## TCP 연결의 여러 종류 (Many Flavors of TCP)
Taho -> **(New)Reno** -> Vegas -> Westwood -> Binary Increase Congestion control(BIC) -> **Cubic** -> **BBR**
- new Reno: 거의 모든 OS에서 기본적으로 사용되는 전통적인 TCP
- Cubic: 현재 리눅스에서 기본적으로 사용되는 TCP
- BBR: 구글에서 개발한 TCP, 가장 빠른 속도를 보임

*혼잡 제어 알고리즘*(congestion control algorithm)의 가장 큰 차이점? -> **congestion window size**의 변화

## TCP 세그먼트 구조 (TCP Segment Structure)
- 헤더
	- souce port(16bit), destination port(16bit)
	- sequence number(32bit): DATA의 순서 - 32bit
	- acknowledgment number(32bit): ACK 번호 - 32bit
	- RST: 연결 설정 재설정
	- SYN: 연결 설정 요청
	- FIN: 연결 종료 요청
	- ACK valid bit(1bit): ACK 번호가 유효한지
	- receive window(16bit): 수신자가 받을 수 있는 데이터 크기 -> flow control
	- checksum(16bit): 오류(biterror) 검출
	- options(0~40byte): 옵션 정보
- payload(데이터): 최대 65,535바이트

## TCP 시퀀스 번호, ACK 번호 (TCP Sequence Number, ACK Number)
예시: 500kb 메시지를 보낼 때, MSS=1000bytes
<Img src="/posts/240613-180336.png" width={2000}/>

500kb = 500,000bytes = 500개의 세그먼트
**시퀀스 번호**: 각 세그먼트의 *첫 번째 바이트*의 바이트 스트림 번호 - 0, 1000, 2000, 3000, 4000
**ACK 번호**: 수신자가 *다음에 받을 세그먼트*의 시퀀스 번호 - 1000, 2000, 3000, 4000, 5000

### 특징
- 패킷은 시퀀스 번호와 ACK 번호를 모두 가지고 있다
	- 데이터 패킷을 ACK 용으로 사용 가능
	- 전이중 통신 가능 (full-duplex)
- 실제로는 0부터 시작하지 않음
	- 초기 시퀀스 번호는 랜덤하게 선택됨. 왜일까? -> 새로운 패킷을 보낼 때마다 시퀀스 번호가 0부터 시작하면, 이전에 보낸 패킷과 *중복*될 수 있기 때문
- 시작 번호를 알 수 있는 방법
	- 3-way handshake: 초기 시퀀스 번호를 알려줌
- 수신자가 순서가 어긋난 패킷을 받았을 때
	- TCP에서 명시하지 않음

### 예시
<Img src="/posts/240613-182445.png" width={500}/>

1. 사용자가 'C'를 입력한다.
2. 호스트 A는 시퀀스 번호 42, 인정 번호 79, 데이터 'C'를 가진 패킷을 전송한다.
3. 호스트 B는 'C'의 수신을 인정하고 'C'를 에코(반사)로 돌려보낸다.
4. 호스트 B는 시퀀스 번호 79, 인정 번호 43, 데이터 'C'를 가진 패킷을 전송한다.
	- 시퀀스 번호 79: A가 보낸 ACK
	- 인정 번호 43: A가 보낸 Seq + 1
5. 호스트 A는 'C'의 수신을 인정하고 시퀀스 번호 43, 인정 번호 80을 가진 패킷을 전송한다.
	- 시퀀스 번호 43: B가 보낸 ACK
	- 인정 번호 80: B가 보낸 Seq + 1

## TCP 왕복 시간, 타임아웃 (TCP Round-Trip Time, Timeout)
> TCP 는 패킷 손실을 회복하기 위해 타임아웃 후 재전송한다.

**Q. Timeout 값을 설정하는 법**
- RTT보다 길게 설정
	- RTT(Round-Trip Time): 패킷을 보내고 ACK를 받는 데 걸리는 시간
	- RTT는 변할 수 있다
- *너무 짧으면*: 성급한 타임아웃, 불필요한 재전송
- *너무 길면*: 세그먼트 손실에 대한 반응이 느림
- 몇 개의 타이머가 필요한가

**Q. RTT를 추정하는 방법**
- *SampleRTT*: 패킷(세그먼트)을 보내고 ACK를 받는 데 걸린 시간
	- 재전송은 무시. 왜? -> RTT가 길어지면 재전송이 빈번해질 수 있음
	- 패킷 윈도우를 보냈음에도 한 번에 하나의 SampleRTT만 측정
	- 변동성이 있으므로 여러 최근 측정치를 평균낸다.

### 지수 가중 이동 평균 (Exponential Weighted Moving Average)
> EstimatedRTT = (1-α) * EstimatedRTT + α * SampleRTT

- 과거 샘플의 영향이 지수적으로 빠르게 감소함
	- $E'=(1-\alpha)\left\{(1-\alpha)E+\alpha S\right\} $
	- $E''=(1-\alpha)\left\{(1-\alpha)\left\{(1-\alpha)E+\alpha S\right\}+\alpha S\right\}$
	- ...
	- $E_n=(1-\alpha)E_{n-1}+\alpha S$
- 일반적으로, α: 0.125
### 타임아웃 간격 (Timeout Interval)
*추정된 RTT*(EstimatedRTT)에 "안전 마진"이 추가됨
- 추정된 RTT의 변동이 크면 안전 마진도 커짐
- 추정된 RTT로부터 SampleRTT 편차 추정
	**DevRTT**: RTT의 변동성
	> DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT|
	- 일반적으로, β: 0.25
- 결론 - TCP의 타임아웃 간격
	> TCP의 *타임아웃 간격*(TimeoutInterval) = *추정된 RTT*(EstimatedRTT) + 4 * *DevRTT*(safety margin)

# 3.5.2 TCP: 신뢰할 수 있는 데이터 전송 (Reliable Data Transfer)
**IP가 불안정하다**
- 데이터가 손상, 분실, 순서변경, 삭제될 수 있다.

**TCP**는 IP의 불안정성을 **보완한다**
- 받은 바이트 스트림은 보낸 것과 정확히 일치함
	- 손상X, 갭X, 중복X, 순서대로
- 사용법
	- 파이프라인 세그먼트
	- 시퀀스 번호, ACK 번호
	- 타임아웃, 재전송
- 재전송은 다음에 의해 트리거됨
	- 타임아웃
	- 중복된 ack

## TCP 송신자 이벤트(TCP Sender Events)
<Img src="/posts/240613-202814.png" width={1000}/>
1. 애플리케이션으로부터 데이터를 받음
	- 시퀀스 번호를 할당하고, 데이터를 세그먼트로 나눔
	- 시퀀스 번호는 데이터의 첫 번째 바이트스트림 번호
	- NextSeqNum = NextSeqNum + 데이터 크기
	- 타이머가 시작됨: 만료 간격 - *Timeout Interval*
2. 타임아웃
	- 아직 인정받지 않은 세그먼트를 재전송(가장 작은 시퀀스 번호)
	- 타이머 재설정
3. ACK 수신
	- ACK가 이전에 인정받지 않은 세그먼트 인정
		- ACKed로 업데이트
		- 아직 인정받지 않은 세그먼트가 있다면 타이머 시작
	- ACK가 이전에 인정받은 세그먼트를 인정
		- 중복 ACK

## TCP: 재전송 시나리오(TCP: Retransmission Scenario)
### 시나리오1: 잃어버린 ACK 시나리오 (Lost ACK Scenario)
<Img src="/posts/240613-204150.png" width={400}/>
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 전송한다.
- 타임아웃 후, 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 재전송한다.
- 호스트 B는 ACK 100을 보낸다.

### 시나리오2: 성급한 타임아웃 시나리오 (Premature Timeout Scenario)
<Img src="/posts/240613-204159.png" width={400}/>
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 전송하고, 이어서 시퀀스 번호 100, 20 바이트의 데이터를 전송한다.
- 호스트 B는 ACK 100과 ACK 120을 전송한다.
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 재전송한다. - 성급한 타임아웃
- 호스트 B는 ACK 120을 다시 전송한다.

### 시나리오3: 누적 ACK 시나리오 (Cumulative ACK Scenario)
<Img src="/posts/240613-204643.png" width={400}/>
- Host A는 시퀀스 번호 92로 8바이트의 데이터를 전송한다.
- 다음으로, 시퀀스 번호 100으로 20바이트의 데이터를 전송한다.
- Host B는 ACK 100을 보내고, 이후 ACK 120을 보낸다. 이 때 ACK 100 전송 실패
- ACK 120을 받은 Host A는 시퀀스 번호 92으로 8바이트의 데이터를 재전송한다.

## TCP ACK 생성(TCP ACK Generation)
- **수신자 이벤트**: 순서대로 도착한 세그먼트가 예상 시퀀스 번호와 일치하며, 이전 모든 데이터는 이미 ACK이 완료된 상태다.
	$\Rightarrow$ **TCP 수신 액션**: 지연된 ACK. 다음 세그먼트를 500ms 동안 기다린다. 다음 세그먼트가 없다면 ACK을 보낸다.
- **수신자 이벤트**: 순서대로 도착한 세그먼트가 예상 시퀀스 번호와 일치하며, 다른 세그먼트에 대한 ACK이 대기 중이다.
	$\Rightarrow$ **TCP 수신 액션**: 즉시 단일 *누적 ACK*을 보내어 순서대로 도착한 두 세그먼트를 모두 ACK한다.
- **수신자 이벤트**: 예상보다 높은 시퀀스 번호를 가진 순서에 맞지 않는 세그먼트가 도착하며, 갭이 감지된다.
	$\Rightarrow$ **TCP 수신 액션**: 즉시 *중복 ACK*을 보내어 다음 예상 바이트의 시퀀스 번호를 나타낸다.
- **수신자 이벤트**: 갭을 부분적으로나 완전히 채우는 세그먼트가 도착한다.
	$\Rightarrow$ **TCP 수신 액션**: 갭의 낮은 쪽에서 시작하는 세그먼트가 도착하면 즉시 ACK을 보낸다.

## TCP 빠른 재전송(TCP Fast Retransmit)
**문제정의**: 타임아웃 기간이 종종 상대적으로 김
**아이디어**: *중복 ACK*을 통해 잃어버린 세그먼트를 식별하고, 즉시 재전송
- 세그먼트가 손실되면, 중복 ACK이 많이 발생할 가능성이 있다.

**TCP 빠른 재전송**
- 중복 ACK이 3개 이상 수신되면, 잃어버린 세그먼트로 간주하고 즉시 재전송
- 가장 작은 시퀀스 번호를 가진 세그먼트를 재전송
- 타임아웃을 기다리지 않음

### 예시 (TCP 빠른 재전송)
<Img src="/posts/240614-232632.png" width={400}/>

- Host A는 시퀀스 번호 92에서 8바이트의 데이터를 전송하고, 이어서 시퀀스 번호 100에서 20바이트의 데이터를 전송한다.
- 시퀀스 번호 100의 데이터가 손실되었고, Host B는 같은 시퀀스 번호에 대해 여러 번(3번) ACK 100을 반복해서 전송한다.
- Host A는 이 *3중 중복 ACK*을 받고, 손실된 시퀀스 번호 100의 데이터 20바이트를 즉시 재전송한다.

# 3.5.3 TCP: 흐름 제어 (TCP Flow Control)
## TCP 흐름 제어 (TCP Flow Control)
<Img src="/posts/240614-233759.png" width={400}/>
- 송신자는 너무 빠르게 데이터를 보내지 말아야 한다.
- 애플리케이션은 TCP 소켓 버퍼에서 데이터를 제거할 수 있다.
- 수신기는 송신자를 제어하여 너무 빠르게 데이터를 보내지 않도록 한다.

수신자는 수신기-송신기 세그먼트 TCP 헤더에 *rwnd*를 포함하여 송신기에 여유 버퍼를 알려준다.
- *RcvBuffer* 크기: 수신기의 버퍼 크기
- 많은 운영체제에서 *RcvBuffer* 크기를 자동으로 조정한다.
송신자는 수신자의 *rwnd*를 확인하고, *rwnd*보다 큰 데이터를 보내지 않는다.


# 3.5.4 TCP: 연결 관리 (TCP Connection Management)
## 연결 관리 (Connection Management)
데이터를 교환하기 전에 송신자와 수신자는 "핸드셰이크" 과정을 통해 아래 사항에 동의한다.
- 연결 설정(서로 연결을 설정하려는 의사 확인)
- 연결 매개변수에 동의

``` java title="클라이언트" showLineNumbers
Socket clientSocket = new Socket("hostname", "port number");
```

``` java title="서버" showLineNumbers
Socket connectionSocket = welcomeSocket.accept();
```

## 연결 설정 합의 (Agreeing to Establish a Connection)
- 양방향(2단계) 핸드셰이크
	- "대화하자" → "확인"
- 양방향 핸드셰이크가 항상 네트워크에서 작동할까?
	- 가변 지연
	- 메시지 손실로 인한 재전송 메시지
	- 메시지 재정렬
	- 상대방을 "볼" 수 없음

### 양방향 핸드셰이크 실패 시나리오 (Two-Way Handshake Failure Scenario)
<Img src="/posts/240614-235542.png" width={400}/>
*ESTAB*: 연결 설정 상태
1. host A: x를 선택하고 `req_conn(x)`를 전송한다.
2. host A: 연결 응답이 오기 전에 `req_conn(x)`를 재전송한다.
3. host B: `acc_conn(x)`로 응답하지만, host A는 연결을 종료한다.
4. host B: 연결이 완료되었다고 판단하지만, 실제로는 반쪽짜리 연결이 된다.

## TCP 3단계 핸드셰이크 (TCP Three-Way Handshake)
<Img src="/posts/240615-001724.png" width={500}/>
1. **SYN**: 클라이언트는 초기 순서 번호 x와 SYN 플래그를 가진 세그먼트를 전송한다.
2. **SYN-ACK**: 서버는 x+1로 응답하고, 자신의 초기 순서 번호 y와 SYN 플래그를 가진 세그먼트를 전송한다.
3. **ACK**: 클라이언트는 y+1로 응답하고, SYN 플래그를 제거한 세그먼트를 전송한다.

### 유한 상태 머신:FSM (Finite State Machine: FSM)
<Img src="/posts/240615-195441.png" width={400}/>

1. 상태: CLOSED -> LISTEN
	`Socket connectionSocket = welcomeSocket.accept();{:java}`
	- 연결이 설정되지 않은 초기 상태로 서버는 클라이언트의 연결 요청을 수락할 준비를 함.
2. 상태: LISTEN -> SYN_RCVD
	`SYN(x){:java}`, `SYNACK(seq=y, ACKnum=x+1){:java}`
	- 클라이언트와의 통신을 위한 새로운 소켓 생성
	- 서버는 `SYN(x)`를 수신하고, `SYNACK(seq=y, ACKnum=x+1)`를 전송하여 클라이언트에게 연결 설정을 알림
3. 상태: SYN_RCVD -> ESTAB
	`ACK(ACKnum=y+1){:java}`
	- 서버가 `ACK(ACKnum=y+1)`을 수신하고, 클라이언트와의 연결이 설정됨
4. 상태: CLOSED -> SYN_SENT
	`Socket clientSocket = newSocket("hostname", "port number");{:java}`
	`SYN(seq=x){:java}`
	- 클라이언트는 `SYN(seq=x)`를 전송하여 서버에게 연결 설정을 요청
5. 상태: SYN_SENT -> ESTAB
	`SYNACK(seq=y, ACKnum=x+1){:java}`, `ACK(ACKnum=y+1){:java}`
	- 클라이언트가 `SYNACK(seq=y, ACKnum=x+1)`을 수신하고, `ACK(ACKnum=y+1)`을 전송하여 서버와의 연결이 설정됨

## TCP: 연결 종료 (TCP: Closing a Connection)
- 클라이언트와 서버는 각자 자신의 연결을 종료한다.
	- *FIN 비트*가 1인 TCP 세그먼트를 보낸다.
	- 수신된 FIN에 대한 *ACK* 응답을 보낸다.
- 동시에 FIN 교환 처리 가능
<Img src="/posts/240615-201931.png" width={500}/>

*클라이언트 상태*
1. **ESTAB**: 연결이 설정된 상태다.
2. **FIN\_WAIT\_1**: 클라이언트가 `clientSocket.close()`를 호출하여 FIN 세그먼트를 전송한다.
    - 이 상태에서는 더 이상 데이터를 보낼 수 없지만 받을 수 있다.
3. **FIN\_WAIT\_2**: 클라이언트는 서버로부터 FIN 세그먼트를 기다린다.
4. **TIMED\_WAIT**: 클라이언트는 2*최대 세그먼트 생명 시간 동안 대기하여 모든 패킷이 소멸되었는지 확인한다.
5. **CLOSED**: 연결이 완전히 종료된 상태다.

*서버 상태*
1. **ESTAB**: 연결이 설정된 상태다.
2. **CLOSE\_WAIT**: 서버가 클라이언트로부터 FIN 세그먼트를 수신하고 응답할 준비를 한다.
3. **LAST\_ACK**: 서버는 FIN 세그먼트를 전송하고, 클라이언트의 ACK를 기다린다.
    - 이 상태에서는 더 이상 데이터를 보낼 수 없다.
4. **CLOSED**: 연결이 완전히 종료된 상태다.
