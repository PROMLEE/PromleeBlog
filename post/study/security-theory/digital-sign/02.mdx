## RSA 서명 (RSA Signature)
### 키 생성 (RSA)
1. 두 소수 $p, q$를 무작위로 선택, $N = pq$로 설정
2. 무작위 공개 지수 $e \in \mathbb{Z}^*_{\phi(N)}$를 선택
3. $d \cdot e \equiv 1 \pmod{\phi(N)}$를 만족하는 $d$를 계산
4. 공개 키 $pk = (N, e)$, 개인 키 $sk = d$를 반환

### 서명 (RSA)
메시지 $M$에 대해 $s = M^d \pmod{N}$을 계산하여 서명 $\sigma =(M, s)$를 생성

### 검증 (RSA)
$\sigma = (M, s)$가 주어졌을 때, $s^e \stackrel{?}{=} M \ (\text{mod} \ N)$을 확인한다. 이 조건이 성립하면 1을 반환하고, 그렇지 않으면 0을 반환한다.

### 정확성 (RSA)
$s^e = (M^d)^e = M^{ed} = M^{1 + k\phi(N)} = M \ (\text{mod} \ N)$이 오일러 정리에 의해 성립한다.

## RSA 패딩: 확률론적 서명 표준 (RSA Padding: Probabilistic Signature Standard)
- 이전 공격을 방지하기 위해 특정 메시지 형식만 허용
- 확률론적 서명 표준(PSS)
	<Img src="/posts/240612-174054.png"/>
	1. 임의의 값 $salt$를 생성
	2. 고정 패딩 8개의 0x00 바이트, 해시 값 $mHash = \text{Hash}(M)$, $salt$를 이어붙여 문자열 $M'$을 생성
		$M' = \text{0x00} \mathbin\Vert \text{0x01} \mathbin\Vert mHash\mathbin\Vert \text{salt} $
	4. $H = \text{Hash}(M')$를 계산
	5. 고정 패딩 $PS$, $0x01$, $salt$를 이어붙여 문자열 $DB$을 생성
		$DB = \text{PS} \mathbin\Vert \text{0x01} \mathbin\Vert \text{salt}$
	7. $maskedDB = \text{MGF}(H) \oplus DB$
	8. 고정 패딩 $TF$를 위해 인코딩된 메시지 $EM$을 생성
		$EM = maskedDB \mathbin\Vert H\mathbin\Vert TF$
#### 정리 (RSA PSS)
- RSA PSS는 확률론적 서명 표준으로, *이전 공격*을 방지하기 위해 특정 메시지 형식만 허용한다.
- RSA PSS는 메시지 $M$에 대해 $salt$를 이용하여 $M'$을 생성하고, $M'$에 대한 해시값 $H$를 계산한다.
- $H$를 이용하여 $DB$를 생성하고, $DB$에 대한 마스킹된 값 $maskedDB$를 계산한다.
- $maskedDB$를 이용하여 인코딩된 메시지 $EM$을 생성한다.


## ElGamal 서명 (ElGamal Signature)
### 키 생성 (ElGamal)
1. 큰 소수 $p$ 와 $\mathbb{Z}_p^*$의 큰 subgroup 생성자 $g$를 선택
2. 임의의 정수 $x \in \{2, 3, \ldots, p-2\}$를 선택
3. $X = g^x \pmod{p}$를 계산
4. 공개 키 $pk = (p, g, X)$, 개인 키 $sk = x$를 반환

### 서명 (ElGamal Signature)
- 비밀 키 $sk = x$와 메시지 $M$이 주어졌을 때
	1. $\mathbb{Z}_{p-1}^*$에서 임의의 원소 $k$를 선택
	2. $r = g^k \pmod{p}$와 $s = (M - xr)k^{-1} \pmod{p-1}$을 계산
	3. 서명 $\sigma = (M(r, s))$를 반환

### 검증 (ElGamal Signature Verification)
- 공개 키 $pk = (p, g, X)$와 메시지 $M$에 대한 서명 $\sigma = (M, r, s)$가 주어졌을 때
	1. $t = X^r \cdot r^s \pmod{p}$를 계산
	2. $t \stackrel{?}{=} g^M \pmod{p}$를 확인한다. 이 조건이 성립하면 1을 반환하고, 그렇지 않으면 0을 반환한다.

### 정확성 (ElGamal Signature correctness)
$$t = X^r \cdot r^s = (g^x)^r \cdot (g^k)^s \\= (g^x) \cdot (g^k)^{(M-rx)k^{-1}} \\= g^{xr+M-rx} \\= g^M \ (\text{mod} \ p)$$

### 보안성 (ElGamal Signature Security)
- 이산 로그 문제가 풀기 어려운 만큼 비밀 키 $x$를 복구하기 어렵다.
- 존재적 위조 공격 (Existential Forgery Attack)
	1. 정수 $i, j$를 선택하고 여기서 $\gcd(j, p-1) = 1$이어야 함
	2. $r = g^i \cdot X^j \ (\text{mod} \ p)$를 계산한다.
	3. $s = -rj^{-1} \ (\text{mod} \ p-1)$를 계산한다.
	4. $M = si \ (\text{mod} \ p-1)$를 계산한다.
	5. $\sigma = (M, (r, s))$를 출력한다.

⇒ 그러면 $t = X^r \cdot r^s \ (\text{mod} \ p)$이 성립하며 $t = g^M \ (\text{mod} \ p)$이므로
$t = X^r \cdot r^s = (g^x)^r \cdot (g^i \cdot g^{xj})^s \\= g^{xr + si - rj^{-1}xj} = g^{si} = g^M \ (\text{mod} \ p)$
따라서 $\sigma = (M, (r, s))$가 유효하다.

## DSA 서명 (DSA Signature)
### 키 생성 (DSA)
1. 순환 부분군 $\mathbb{G}$ 생성
	- 소수 $p$ 선택
	- $\mathbb{Z}_p^*$는 소수 $p$에 대한 유한체의 곱셈 군
	- $\mathbb{Z}_p^*$의 순서란 이 군에 속하는 모든 원소의 개수: $p-1$
	- $q$는 $p-1$의 소인수 중 하나인 소수
	- 원소 개수가 $q$인 부분군 $\mathbb{G}$를 생성
2. 부분군 $\mathbb{G}$의 임의의 생성자 $g$ 선택
3. $\mathbb{Z}_q$에서 임의의 $x$ 선택 후 $X = g^x \pmod{p}$ 계산
4. 공개 키 $pk = (p, q, g, X)$, 개인 키 $sk = x$를 반환

### 서명 (DSA Signature)
비밀 키 $sk = x$와 메시지 $M$이 주어졌을 때
1. $\mathbb{Z}_q^*$에서 임의의 $k$ 선택
2. $r = (g^k \pmod{p}) \pmod{q}$ 계산
3. $s = k^{-1}(H(M) + xr) \pmod{q}$ 계산
4. 서명 $\sigma = (M,(r, s))$를 반환

### 검증 (DSA Signature Verification)
공개 키 $pk = (p, q, g, X)$와 메시지 $M$에 대한 서명 $\sigma = (M, (r, s))$가 주어졌을 때
1. $0 < r < q, 0 < s < q$를 확인
2. $w = s^{-1} \pmod{q}$를 계산
3. $u_1 = H(M) \cdot w \pmod{q}$, $u_2 = rw \pmod{q}$를 계산
4. $v = (g^{u_1}X^{u_2} \pmod{p}) \pmod{q}$를 계산
5. $v \stackrel{?}{=} r$를 확인한다. 이 조건이 성립하면 1을 반환하고, 그렇지 않으면 0을 반환한다.

### 정확성 (DSA Signature correctness)
$v = g^{u_1}X^{u_2} = g^{u_1+xu_2}$
$= g^{w(H(M)+xr)}$
$= g^{k(H(M)+xr)^{-1}(H(M)+xr)}$
$= g^{k} \ (\text{mod} \ p) \rightarrow (\because s = k^{-1}(H(M)+xr))$

$\Longrightarrow  r \pmod{q} = g^k \pmod{q} = g^{u_1}X^{u_2} \pmod{q} = v$