## 스트림 암호란? (Stream Cipher)
> 비트 단위로 암호화하는 대칭키 암호화 방식

입력: 지속적으로 요소를 받아들임
출력: 한 번에 하나의 요소 출력
블록 암호보다 빠름
키를 단 한 번만 사용
알려진 평문 공격에 취약 : $M \oplus C = M \oplus (M \oplus k) = k$
예시) LFSR, RC4, ChaCha

## 난수 (Random Numbers)
- 암호학에서의 광범위한 사용
	- 공개 키 암호화에서의 개인 키
	- 스트림 암호를 위한 키
	- 임시 세션 키로 사용할 대칭 키
- 요구사항
	- 무작위성
		- 균일 분포: 각 숫자의 발생 빈도가 동일해야 함
		- 독립성: 어떤 값도 다른 값에서 추론될 수 없음
	- 예측 불가능성
		- 각 숫자는 다른 숫자와 통계적으로 독립적임
		- 누구도 시퀀스의 이전 요소를 기반으로 향후 요소를 예측할 수 없어야 함

## 난수 vs 의사 난수 (Random Numbers vs Pseudo-Random Numbers)
- 진짜 난수 상성기 True random number generator(TRNG)
	- 실현하는 데 비용이 많이 든다
	- 비결정론적인 원천 사용
	- 방사능, 가스 방출, 누출된 캐퍼시터 등과 같은 예측불가능한 자연 과정 측정
	- 최근 프로세서들에 점점 제공된다
- 의사 난수 Pseudorandom numbers
	- 통계적 난수 테스트를 만족하는 순서열 생성
	- 결정론적인 원천 사용 - 예측 가능성 높음

## RC4 개요 (RC4 Overview)
RC: Rivest Cipher
가변 키 크기를 가지는 스트림 암호로 바이트 단위 연산으로 구성
- 소프트웨어에서 빠를 것으로 예상

무작위 순열 사용을 기반으로 함

## RC4: S의 초기화 (RC4: Initialization of S)
S: 256바이트 크기의 배열
- 0부터 255까지의 숫자가 오름차순으로 한 번씩 나타남
T: 임시 백터로 첫 keylen 원소들은 k에서 복사
- keylen: 키의 길이
- k: 키 - T를 채울 필요가 있을 때마다 반복됨
T를 사용하여 S 순열
```python
j = 0
for i=0 to 255 do
	j = (j + S[i] + T[i]) mod 256;
	Swap(S[i], S[j]);
```
## RC4: 스트림 생성 (RC4: Stream Generation)
S[i] 의 모든 요소 순회
```python
i = 0
j = 0
while(true)
	i = (i + 1) mod 256
	j = (j + S[i]) mod 256
	Swap(S[i], S[j])
	t = (S[i] + S[j]) mod 256
	k = S[t]
```
암호화: k값과 평문의 다음 바이트 XOR
복호화: k값과 암호문의 다음 바이트 XOR

## RC4: 보안성 분석 (RC4: Security Analysis)
키 크기가 합리적이면(e.128 bit), RC4은 안전하다고 여겨짐
WEB(Wired Equivalant Privacy) 프로토콜에 취약

# 운용 모드 (Modes of Operation)
## 운용 모드란? (Modes of Operation)
> 블록 암호를 사용하여 메시지를 암호화하는 방법

블록 암호의 한계: 평문의 고정된 길이
운용 모드: 블록 암호를 사용하여 임의 길이의 메시지를 암호화
- ECB(Electronic Codebook) 모드
- CBC(Cipher Block Chaining) 모드
- CFB(Cipher Feedback) 모드
- OFB(Output Feedback) 모드
- CTR(Counter) 모드

## ECB 모드 (Electronic Codebook Mode)
암호화: 시간에 따라 블록 단위로 암호화
- 시간 n에서 $P_n$ 암호화 -> $C_n$
복호화: 시간에 따라 블록 단위로 복호화
- 시간 n에서 $C_n$ 복호화 -> $P_n$

장점
- 블록 동기화 필요 없음
- 전송 오류가 해당 블록에만 영향을 미침
- 병렬 처리 가능

단점
- 결정적 암호화
- 치환 공격에 취약: 같은 평문 블록은 같은 암호문 블록으로 변환 가능

## CBC 모드 (Cipher Block Chaining Mode)
암호화: 이전 블록의 암호문과 키 K를 XOR 연산
- $C_n = E_K(P_n \oplus C_{n-1})$
복호화: 이전 블록의 암호문과 키 K를 XOR 연산
- $P_n = D_K(C_n) \oplus C_{n-1}$

초기화 벡터 필요

## CFB 모드 (Cipher Feedback Mode)
암호화: 초기화 벡터를 키 K와 XOR 사용하여 암호화하여 사용하는 모드