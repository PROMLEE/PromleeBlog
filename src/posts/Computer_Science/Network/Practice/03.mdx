# 개요
## 멀티클라이언트 서버란?
_[실습 2](/blog/Computer_Science/Network/Practice/2)에서 진행했던 파일들로 이어서 진행_
클라이언트 파일을 두 개 실행한 후에 서버와 통신 시도를 해보자
### TCP
-> 처음 실행한 하나의 클라이언트는 잘 작동하지만, 나머지 하나는 작동이 멈추었다.
![240427-214117](/posts/240427-214117.png)

### UDP
-> UDP는 서버와 통신이 잘 되었다.
![240427-213935](/posts/240427-213935.png)

## 멀티클라이언트에서 UDP와 TCP의 차이점

1. 연결 지향성 (Connection-Oriented) vs 비 연결성 (Connectionless)
	- TCP
		연결 지향성인 TCP는 데이터를 전송하기 전 클라이언트와 서버 간 통신 세션을 확립해야 한다.
		즉, 클라이언트와 서버가 각각의 연결을 추적하고 관리해야 한다.
		두 번째 클라이언트는 **이미 연결이 확립된 상태**에서 다시 연결을 시도하려고 하기에 오류가 발생한다.
	- UDP
		비 연결성인 UDP는 명시적인 연결 없이도 데이터를 전송할 수 있다.
		따라서 클라이언트와 서버가 각각의 연결을 추적하고 관리할 필요가 없다.
		따라서 두 번째 클라이언트도 서버와 통신이 가능하다.

2. 자원 관리 문제
	- TCP
		TCP는 연결마다 **소켓**을 생성하고 관리해야 한다.
		서버가 수용할 수 있는 동시 연결 수에 한계가 있음.
	- UDP
		연결을 관리할 필요가 없기 때문에 더 많은 클라이언트와 통신이 가능하다.
		서버 자원을 덜 소모함

3. 데이터 신뢰성 문제
	- TCP
		TCP는 데이터 전송 시 데이터의 신뢰성을 보장한다.
		데이터가 손실되거나 손상되었을 때 재전송을 요청한다.
		따라서 **데이터의 신뢰성**이 중요하기에 연결 상태를 정확하게 관리하고 조정해야 한다.
	- UDP
		UDP는 데이터 전송 시 데이터의 신뢰성을 보장하지 않는다.
		데이터가 손실되거나 손상되었을 때 재전송을 요청하지 않는다.

>  UDP에는 '연결'에 대한 실제 개념이 없지만, TCP는 '연결'해야 하기 때문

TCP 서버 코드에서 Accept와 Read 가 있는 이유
	$\rightarrow$ 루프가 종료되기 전까지 하나의 클라이언트를 accept하고 다른 클라이언트를 accept 하지 않는다.
```go showLineNumbers{18} title="TCPServer.go"
...
for {
	conn, _:= listener.Accept()
	fmt.Printf("Connection request from %s\n", conn.RemoteAddr().String())
	count, _ := conn.Read(buffer)
	conn.Write(bytes.ToUpper(buffer[:count]))
	conn.Close()
}
...
```
# 실습 - 멀티클라이언트 서버 구현
> TCP 서버에서 다중 클라이언트를 처리할 수 있도록 코드를 수정하기
## 해결 방안
### C, C++, Java, or Python 등 에서의 해결 방안
1. 멀티 스레드/멀티프로세스 방법(Multi-thread / Multi-process method)
	- 서버에는 클라이언트 연결을 기다리는 서버 소켓이 있는 **메인 스레드**가 있다.
	- 클라이언트가 서버에 연결되고 서버가 `accept(){:go}`를 수행
		- 서버는 해당 클라이언트(소켓)를 위한 새 소켓을 가짐
		- 서버는 그 연결을 위한 새로운 **클라이언트 스레드/프로세스**를 생성
			-	클라이언트 소켓은 클라이언트 스레드/프로세스에 주어집니다.
	- 그러면 서버의 이 클라이언트 스레드/프로세스는 클라이언트 소켓을 사용하여 클라이언트와 통신합니다.
	- N개의 클라이언트 연결 시, N개의 클라이언트 스레드/프로세스, N개의 클라이언트 소켓, 메인 스레드에 1개의 서버 소켓이 있게 됨.
2. 넌 블로킹 소켓 방법(Non-blocking socket method)
	- 서버는 클라이언트 연결을 기다리는 서버 소켓이 있는 하나의 스레드/프로세스만을 가진다.
	- 서버는 연결된 클라이언트 소켓의 배열을 유지 관리함
	- 새 클라이언트에 연결이 들어오면, 그 클라이언트 소켓을 이 배열에 넣는다.
	- 서버는 `select(){:go}` 함수를 사용하여 동시에 모든 소켓(클라이언트 소켓 + 서버 소켓)을 기다린다.
		- 소켓은 총 N+1개가 됨
	- 어떤 소켓에서 이벤트가 발생하면, `select(){:go}` 함수는 그 소켓을 반환하고, 서버는 그 소켓에 대한 작업을 수행한다.
		- 이때 이벤트는 패킷 수신, 연결 해제, 타이머 등이 될 수 있다.
### Go lang에서의 해결 방안
Go 언어는 동시성을 염두에 두고 설계된 언어이다. 
따라서 Go 언어에서는 멀티 스레드/멀티프로세스 방법보다는 **__고루틴(Go routine)__**을 사용하는 것이 더 효율적이다.
- 고루틴이란?
	- 스레드와 비슷한 개념으로 사용할 수 있지만, 더 간단하고 쉬우며 메모리 사용도 적다.
	- '멀티 스레드' 방법으로 생각할 수 있으며, 사용하기 더 쉽고 효율적이다.
	- 넌 블로킹 소켓 방법도 구현 가능하지만 더 낮은 수준의 API를 사용해야 한다.
- 고루틴은 여러 네트워크 연결을 관리하는 서버를 구현할 때 특히 유용하다.
	- 각 클라이언트 연결에 대해 별도의 고루틴을 생성하고, 이들이 독립적으로 실행되도록 한다.
	- 서버의 확장성과 유지 관리가 용이해짐

## 요구사항
1. TCPServer.go 코드를 수정함 -> MultiTCPServer.go
2. 모든 요구사항은 실습2에서의 요구사항과 동일함
3. 필요 기능
	- 연결될 때 각 클라이언트에 **고유한 ID** 부여 (client 1, client 2, ...)
		- 이 ID는 클라이언트와 연결이 끊어진 후에도 변경되어서는 안됨
	- 새로운 클라이언트가 연결되거나 기존 클라이언트의 연결이 끊어질 때 **현재 시간, 클라이언트 ID, 서버에 연결된 클라이언트 수** 출력
	```shell title="출력 예시"
	[Time: HH:MM:SS] Client X connected. Number of clients connected = N
	[Time: HH:MM:SS] Client Y disconnected. Number of clients connected = M
	```
	- 서버는 10초마다 **연결된 클라이언트 수**를 출력 해야 한다.
	```shell title="출력 예시"
	[Time: HH:MM:SS] Number of clients connected = N
	```
4. 세 명 이상의 클라이언트로 프로그램을 테스트해야 함

## 참고
[Go 공식 문서 Goroutine 실습](https://go.dev/tour/concurrency/1)

```go showLineNumbers highlight={9}
...
func say(s string) {
	for i := 0; i < 5; i++ {
		time.Sleep(100 * time.Millisecond)
		fmt.Println(s)
	}
}
func main() {
	go say("world")
	say("hello")
}
```
```shell title="result" highlight-line={2, 3, 6, 7}
hello
world
world
hello
hello
world
world
hello
hello
```
함수 `say(){:go}` 는 100밀리세컨드마다 5번 반복하여 문자열을 출력하는 함수이다.
`main(){:go}` 함수에서 가장 먼저, go 키워드가 붙지 않은 `say("hello"){:go}` 함수가 실행된다. 이 함수는 **main 고루틴** 이라고 불린다.
그 다음, go 키워드가 붙은 `say("world"){:go}` 함수가 실행된다. 이 함수는 별도의 고루틴에서 실행되며 **서브 고루틴**이라고 불린다.
main 고루틴이 종료되면 프로그램이 종료되기 때문에 서브 고루틴이 종료되기 전까지 기다리지 않는다.
따라서 서브 고루틴의 마지막 출력은 main 고루틴이 종료되면서 출력되지 않는다.
이를 참고해 서브 고루틴이 종료되기 전까지 기다리는 방법을 찾아보아야 할 것이다.

## 해결
### 실행 결과
![240428-225929](/posts/240428-225929.png)
### 코드
```go showLineNumbers title="MultiTCPServer.go" highlight{66,72,77}
package main

import (
	"fmt"
	"net"
	"os"
	"os/signal"
	"strings"
	"sync"
	"syscall"
	"time"
)

// PortIDMap은 포트와 ID를 매핑하기 위한 구조체입니다.
type PortIDMap struct {
	mu   sync.Mutex // 맵 동시 접근을 위한 뮤텍스
	data map[string]int
}

// NewPortIDMap은 새로운 PortIDMap 인스턴스를 생성합니다.
func NewPortIDMap() *PortIDMap {
	return &PortIDMap{
		data: make(map[string]int),
	}
}

// Set은 포트에 대한 ID를 설정합니다.
func (p *PortIDMap) Set(port string, id int) {
	p.mu.Lock()
	defer p.mu.Unlock()
	p.data[port] = id
}

// Get은 주어진 포트의 ID를 반환합니다.
func (p *PortIDMap) Get(port string) (int, bool) {
	p.mu.Lock()
	defer p.mu.Unlock()
	id, exists := p.data[port]
	return id, exists
}

func main() {
	serverPort := "0000"
	listener, _ := net.Listen("tcp", ":"+serverPort)
	fmt.Printf("Server is ready to receive on port %s\n", serverPort)
	// 서버 종료 시그널을 받으면 종료
	c := make(chan os.Signal)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-c
		fmt.Println("Bye bye~")
		os.Exit(0)
	}()
	// 클라이언트 ID와 연결된 클라이언트 수를 관리하기 위한 변수
	connectionID := 0
	connectionN := 0
	// 10초마다 연결된 클라이언트 수 출력
	go func() {
		for {
			fmt.Printf("[Time: %s] Number of clients connected = %d\n", time.Now().Format("15:04:05"), connectionN)
			time.Sleep(time.Second * 10)
		}
	}()
	// 클라이언트 ID 매핑
	portmap := NewPortIDMap()
	for { // 입력을 계속 받기 위한 무한 루프
		conn, _ := listener.Accept() // 클라이언트의 연결을 받음
		connectionID++
		go func(conn net.Conn) {  // 고루틴을 사용하여 클라이언트 별로 별도의 스레드를 생성
			buffer := make([]byte, 1024)
			requestCount := 0 // 클라이언트의 요청 수
			connectionN++
			fmt.Printf("Connection request from %s\n", conn.RemoteAddr().String())
			fmt.Printf("[Time: %s] Client %d connected. Number of clients connected = %d\n", time.Now().Format("15:04:05"), connectionID, connectionN)
			portmap.Set(conn.RemoteAddr().String(), connectionID)	// 클라이언트 ID 매핑
			for {
				count, _ := conn.Read(buffer)												 // 클라이언트의 요청을 받음
				requestCount++                                       // 클라이언트의 요청 수 증가
				texts := strings.Split(string(buffer[:count]), "@@") // 요청을 @ 기준으로 분리
				id, _ := portmap.Get(conn.RemoteAddr().String())	// 클라이언트 ID 가져오기
				... // 데이터 처리 로직 작성
				} else if texts[0] == "5" { // 클라이언트 연결 종료
					connectionN--  // 클라이언트 연결 수 감소
					fmt.Printf("[Time: %s] Client %d disconnected. Number of clients connected = %d\n", time.Now().Format("15:04:05"), id, connectionN)
					conn.Close()
					return
				}
			}
		}(conn)
	}
}
```

### 코드 설명
1. `PortIDMap{:go}` 구조체
	- 포트와 ID를 매핑하기 위한 구조체
	- `Set(){:go}` 메서드: 포트에 대한 ID를 설정
	- `Get(){:go}` 메서드: 주어진 포트의 ID를 반환
2. `main(){:go}` 함수
	- 서버 포트를 설정하고 클라이언트 연결을 받음
	- 서버 종료 시그널을 받으면 종료
	- 클라이언트 ID와 연결된 클라이언트 수를 관리하기 위한 변수 설정
	- 10초마다 연결된 클라이언트 수를 출력하는 고루틴 생성
	- 클라이언트 ID를 매핑하기 위한 `PortIDMap{:go}` 인스턴스 생성
	- 클라이언트 연결을 받기 위한 무한 루프
		- 클라이언트 ID 증가
		- 클라이언트 연결 수 증가
		- 클라이언트 연결 요청 시 클라이언트 ID와 연결된 클라이언트 수 출력
		- 클라이언트 ID 매핑
		- 클라이언트 요청 처리
		- 클라이언트 연결 종료 시 클라이언트 ID와 연결된 클라이언트 수 출력


## 비고
1. goroutine을 사용하는	위치
	- `for{:go}` 루프 내에서 `go func(){:go}`를 사용하여 클라이언트 별로 고루틴을 생성하도록 했었음
	- 이렇게 하면 클라이언트가 연결될 때마다 고루틴이 생성되어야 하지만, 실제로는 클라이언트가 연결될 때마다 고루틴이 생성되지 않았음
	- 따라서 `for{:go}` 루프 밖에서 고루틴을 생성하도록 수정함
2. 클라이언트 ID와 연결된 클라이언트 수를 관리하는 방법
	- 클라이언트 ID와 연결된 클라이언트 수를 관리하기 위해 `connectionID{:go}`와 `connectionN{:go}` 변수를 사용했었음
	- 클라이언트 ID와 연결된 클라이언트 수를 매핑하기 위해 `PortIDMap{:go}` 구조체를 사용하도록 수정함

