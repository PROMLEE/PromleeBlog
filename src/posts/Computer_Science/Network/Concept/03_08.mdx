# 3.5.1 연결 지향 전송: TCP (Connection-Oriented Transport: TCP)
## TCP 개요
- **연결 지향적**(Connection-Oriented)
	- 악수(handshake, 제어 메시지 교환)은 데이터 교환 전 송수신자의 상태/매개변수를 초기화함
	- 논리적인 종단 간 연결이며, 전화 회선처럼 실제 회로는 아님
		- 네트워크 내부에 상태/연결 정보 없음
- 일대일 통신
	- 한 송신자, 한 수신자
- 전이중 데이터
	- 같은 연결에서 양방향 데이터 흐름
- 흐름 제어
	- 수신자가 송신자의 속도에 맞춰 데이터를 받을 수 있도록 함
	- 송신자가 수신자를 압도하지 않음
- 신뢰할 수 있는, 순서대로 정렬된 바이트 스트림
	- 메시지 경계가 없다
	- 메시지를 분할하여 **TCP 세그먼트**를 사용하여 전송
		- MSS(Maximum Segment Size): 한 번에 전송할 수 있는 최대 데이터 크기
- 파이프라인 방식
	- TCP 혼잡 및 흐름 제어가 윈도우 크기 결정 = **min(flow control, congestion control)** -> dynaminc/adaptive

## TCP 연결의 여러 종류 (Many Flavors of TCP)
Taho->**(New)Reno**->Vegas->Westwood->Binary Increase Congestion control(BIC)->**Cubic**->**BBR**
- new Reno: 거의 모든 OS에서 기본적으로 사용되는 전통적인 TCP
- Cubic: 리눅스에서 기본적으로 사용되는 TCP
- BBR: 구글에서 개발한 TCP, 가장 빠른 속도를 보임

혼잡 제어 알고리즘(congestion control algorithm)의 가장 큰 차이점? -> **congestion window size**의 변화

## TCP 세그먼트 구조 (TCP Segment Structure)
- 헤더: 20바이트
	- souce port(16bit), destination port(16bit)
	- sequence number(32bit): DATA의 순서 - 32bit
	- acknowledgment number(32bit): ACK 번호 - 32bit
	- SYN: 연결 설정 요청
	- FIN: 연결 종료 요청
	- ACK valid bit(1bit): ACK 번호가 유효한지
	- receive window(16bit): 수신자가 받을 수 있는 데이터 크기 -> flow control
	- checksum(16bit): 오류(biterror) 검출
	- options(0~40byte): 옵션 정보
- payload(데이터): 최대 65,535바이트

## TCP 시퀀스 번호, ACK 번호 (TCP Sequence Number, ACK Number)
예시: 500kb 메시지를 보낼 때, MSS=1000bytes
500kb = 500,000bytes = 500개의 세그먼트

시퀀스 번호: 각 세그먼트의 첫 번째 바이트의 **바이트 스트림 번호** - 0, 1000, 2000, 3000, 4000
ACK 번호: 수신자가 **다음에 받을 세그먼트**의 시퀀스 번호 - 1000, 2000, 3000, 4000, 5000
### 특징
- 패킷은 시퀀스 번호와 ACK 번호를 모두 가지고 있다
	- 데이터 패킷을 ACK 용으로 사용 가능
	- 전이중 통신 가능 (full-duplex)
- 실제로는 0부터 시작하지 않음
	- 초기 시퀀스 번호는 랜덤하게 선택됨. 왜일까? -> 새로운 패킷을 보낼 때마다 시퀀스 번호가 0부터 시작하면, 이전에 보낸 패킷과 중복될 수 있기 때문
- 시작 번호를 알 수 있는 방법
	- 3-way handshake: 초기 시퀀스 번호를 알려줌
- 수신자가 순서가 어긋난 패킷을 받았을 때
	- TCP에서 명시하지 않음

### 예시
- 사용자가 'C'를 입력한다.
- 호스트 A는 시퀀스 번호 42, 인정 번호 79, 데이터 'C'를 가진 패킷을 전송한다.
- 호스트 B는 'C'의 수신을 인정하고 'C'를 에코(반사)로 돌려보낸다.
- 호스트 B는 시퀀스 번호 79, 인정 번호 43, 데이터 'C'를 가진 패킷을 전송한다.
	- 시퀀스 번호 79: A가 보낸 ACK
	- 인정 번호 43: A가 보낸 Seq + 1
- 호스트 A는 'C'의 수신을 인정하고 시퀀스 번호 43, 인정 번호 80을 가진 패킷을 전송한다.
	- 시퀀스 번호 43: B가 보낸 ACK
	- 인정 번호 80: B가 보낸 Seq + 1

## TCP 왕복 시간, 타임아웃 (TCP Round-Trip Time, Timeout)
TCP 는 패킷 손실을 회복하기 위해 타임아웃 후 재전송한다.
- Timeout 값을 설정하는 법
	- RTT보다 길게 설정
		- RTT(Round-Trip Time): 패킷을 보내고 ACK를 받는 데 걸리는 시간
		- RTT는 변할 수 있다
	- 너무 짧으면: 성급한 타임아웃, 불필요한 재전송
	- 너무 길면: 세그먼트 손실에 대한 반응이 느림
	- 몇 개의 타이머가 필요한가
- RTT를 추정하는 방법
	- SampleRTT: 패킷(세그먼트)을 보내고 ACK를 받는 데 걸린 시간
		- 재전송은 무시. 왜? -> RTT가 길어지면 재전송이 빈번해질 수 있음
	- 변동성이 있으므로 여러 최근 측정치를 평균낸다.
- 지수 가중 이동 평균(Exponential Weighted Moving Average)
	> EstimatedRTT = (1-α) * EstimatedRTT + α * SampleRTT
	- 과거 샘플의 영향이 지수적으로 빠르게 감소함
		- $E'=(1-\alpha)\left\{(1-\alpha)E+\alpha S\right\} $
		- $E''=(1-\alpha)\left\{(1-\alpha)\left\{(1-\alpha)E+\alpha S\right\}+\alpha S\right\}$
		- ...
		- $E_n=(1-\alpha)E_{n-1}+\alpha S$
	- 일반적으로, α: 0.125
- 타임아웃 간격(TimeOut Interval): **추정된 RTT(EstimatedRTT)**에 "안전 마진"이 추가됨
	- 추정된 RTT의 변동이 크면 안전 마진도 커짐
	- DevRTT: RTT의 변동성
		> DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT|
		- 일반적으로, β: 0.25
	- TCP의 타임아웃 간격(TimeoutInterval) = 추정된 RTT(EstimatedRTT) + 4 * DevRTT(safety margin)

# 3.5.2 TCP: 신뢰할 수 있는 데이터 전송(Reliable Data Transfer)
## 신뢰할 수 있는 데이터 전송(Reliable Data Transfer)
- **IP가 불안정하다**
	- 데이터가 손상, 분실, 순서변경, 삭제될 수 있다.
- TCP는 IP의 불안정성을 보완한다
	- 받은 바이트 스트림은 보낸 것과 정확히 일치함
	- 사용법
		- 파이프라인 세그먼트
		- 시퀀스 번호, ACK 번호
		- 타임아웃, 재전송
	- 재전송은 다음에 의해 트리거됨
		- 타임아웃
		- 중복된 ack
## TCP 송신자 이벤트(TCP Sender Events)
1. 애플리케이션으로부터 데이터를 받음
	- 시퀀스 번호를 할당하고, 데이터를 세그먼트로 나눔
	- 타이머가 시작됨
2. 타임아웃
	- 타이머가 만료되면, 세그먼트를 재전송
	- 타이머 재설정
3. ACK 수신
	- ACK가 이전에 인정받지 않은 세그먼트 인정
		- ACKed로 업데이트
	- ACK가 이전에 인정받은 세그먼트를 인정
		- 중복 ACK

## TCP: 재전송 시나리오(TCP: Retransmission Scenario)
### 시나리오1
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 전송한다.
- 타임아웃 후, 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 재전송한다.
- 호스트 B는 ACK 100을 보낸다.
- 문제: 잃어버린 ACK 시나리오

### 시나리오2
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 전송하고, 이어서 시퀀스 번호 100, 20 바이트의 데이터를 전송한다.
- 호스트 B는 ACK 100과 ACK 120을 전송한다.
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 재전송한다.
- 호스트 B는 ACK 120을 다시 전송한다.
- 문제: 성급한 타임아웃 시나리오

### 시나리오3
- Host A는 시퀀스 번호 92로 8바이트의 데이터를 전송한다.
- 다음으로, 시퀀스 번호 100으로 20바이트의 데이터를 전송하지만, 이 데이터는 손실된다 (X로 표시).
- Host B는 시퀀스 번호 100의 데이터를 수신하지 못했기 때문에 ACK 100을 전송하여 이를 Host A에 알린다.
- 그 후, Host A는 시퀀스 번호 120으로 15바이트의 데이터를 전송하고, Host B는 ACK 120을 보낸다.
- 문제: 누적 ACK을 시나리오

## TCP ACK 생성(TCP ACK Generation)
- 수신자 이벤트: 순서대로 도착한 세그먼트가 예상 시퀀스 번호와 일치하며, 이전 모든 데이터는 이미 ACK이 완료된 상태다.
	- TCP 수신 액션: 지연된 ACK. 다음 세그먼트를 500ms 동안 기다린다. 다음 세그먼트가 없다면 ACK을 보낸다.
- 수신자 이벤트: 순서대로 도착한 세그먼트가 예상 시퀀스 번호와 일치하며, 다른 세그먼트에 대한 ACK이 대기 중이다.
	- TCP 수신 액션: 즉시 단일 누적 ACK을 보내어 순서대로 도착한 두 세그먼트를 모두 ACK한다.
- 수신자 이벤트: 예상보다 높은 시퀀스 번호를 가진 순서에 맞지 않는 세그먼트가 도착하며, 갭이 감지된다.
	- TCP 수신 액션: 즉시 중복 ACK을 보내어 다음 예상 바이트의 시퀀스 번호를 나타낸다.
- 수신자 이벤트: 갭을 부분적으로나 완전히 채우는 세그먼트가 도착한다.
	- TCP 수신 액션: 갭의 낮은 쪽에서 시작하는 세그먼트가 도착하면 즉시 ACK을 보낸다.

## TCP 빠른 재전송(TCP Fast Retransmit)
문제정의: 타임아웃 기간이 종종 상대적으로 김
아이디어: 중복 ACK을 통해 잃어버린 세그먼트를 식별하고, 즉시 재전송
	- 세그먼트가 손실되면, 중복 ACK이 많이 발생할 가능성이 있다.

TCP 빠른 재전송
	- 중복 ACK이 3개 이상 수신되면, 잃어버린 세그먼트로 간주하고 즉시 재전송
	- 가장 작은 시퀀스 번호를 가진 세그먼트를 재전송
	- 타임아웃을 기다리지 않음

예시)
- Host A는 시퀀스 번호 92에서 8바이트의 데이터를 전송하고, 이어서 시퀀스 번호 100에서 20바이트의 데이터를 전송한다.
- 시퀀스 번호 100의 데이터가 손실되었다는 표시(X)로 인해, Host B는 같은 시퀀스 번호에 대해 여러 번(3번) ACK 100을 반복해서 전송한다.
- Host A는 이 3중 중복 ACK을 받고, 손실된 시퀀스 번호 100의 데이터 20바이트를 즉시 재전송한다.
# 3.5.3 TCP: 흐름 제어 (TCP Flow Control)
# 3.5.4 TCP: 연결 관리 (TCP Connection Management)
## TCP 흐름 제어 (TCP Flow Control)
- 데이터를 교환하기 전에, 발신자와 수신자는 "핸드셰이크" 과정을 통해 아래 사항에 동의한다.
  - 연결을 설정하기로 동의한다(상대방이 연결 설정에 동의한다는 것을 알고 있다).
  - 연결 매개변수에 동의한다.

- 응용 프로그램
  - 연결 상태: ESTAB
  - 연결 변수:
    - seq # 클라이언트에서 서버로
    - 서버에서 클라이언트로
    - 서버, 클라이언트에서의 rcvBuffer 크기

- 네트워크
  - Socket clientSocket = newSocket("hostname","port number");
  - Socket connectionSocket = welcomeSocket.accept();

### 추가 설명

핸드셰이크 과정은 네트워크에서 서버와 클라이언트 간에 데이터 전송을 시작하기 전에 수행하는 초기 단계이다. 이 과정에서 두 시스템은 서로의 존재를 확인하고, 연결을 수립할 준비가 되었다는 것을 알린다. 핸드셰이크는 연결의 신뢰성을 보장하고, 데이터 전송 중에 발생할 수 있는 오류를 최소화하는 데 중요한 역할을 한다.

연결 변수들은 다음과 같다:
- seq # (Sequence Number): 데이터 패킷을 식별하고 순서대로 조립하기 위한 번호이다.
- rcvBuffer (Receive Buffer): 데이터를 수신하는 버퍼의 크기로, 서버와 클라이언트 각각에서 설정될 수 있다. 이 크기는 네트워크의 데이터 흐름을 조절하는 데 사용된다.

Socket 프로그래밍에서는 `newSocket` 함수를 사용하여 새로운 소켓을 생성하고, 호스트 이름과 포트 번호를 지정하여 네트워크 연결을 초기화한다. `welcomeSocket.accept()`는 서버 측에서 클라이언트의 연결 요청을 수락하며, 이로 인해 서버와 클라이언트 간의 연결이 성립된다.

## 연결을 설정하기로 합의 (Agreeing to Establish a Connection)
- 2단계 핸드셰이크:
	- "대화하자" → "확인"

- 질문: 2단계 핸드셰이크는 항상 네트워크에서 작동할까?
  - 가변 지연
  - 메시지 손실로 인한 재전송 메시지 (예: req_conn(x))
  - 메시지 재정렬
  - 상대방을 "볼" 수 없음
	
- 2단계 핸드셰이크 실패 시나리오:
	- 클라이언트는 연결을 종료하고, 서버는 x를 잊어버림
	- 결과는 클라이언트가 없는 반 열린 연결이 됨

### 추가 설명

2단계 핸드셰이크는 기본적으로 "대화하자"라고 요청하고, 상대방이 "확인"으로 응답하는 과정을 포함한다. 이는 서버와 클라이언트가 서로 연결을 시작하기로 합의했음을 의미한다.

그러나, 이런 방식의 핸드셰이크는 다음과 같은 이유로 항상 신뢰성 있는 연결을 보장하지 못할 수 있다:
- **가변 지연**: 네트워크의 상태나 트래픽 양에 따라 메시지가 도착하는 시간이 달라질 수 있다.
- **재전송 메시지**: 메시지가 중간에 손실되면, 손실된 메시지를 다시 전송해야 한다. 이 경우, 연결 요청 메시지(req_conn(x))와 같은 메시지가 여러 번 전송될 수 있다.
- **메시지 재정렬**: 네트워크에서 메시지가 전송된 순서대로 도착하지 않을 수 있다. 이는 메시지 처리에 혼란을 줄 수 있다.
- **상대방을 볼 수 없음**: 네트워크 통신은 물리적으로 서로를 볼 수 없기 때문에, 상대방의 현재 상태나 준비 상태를 정확히 알 수 없다.

이러한 요소들은 2단계 핸드셰이크의 신뢰성을 저하시킬 수 있으며, 따라서 보다 견고한 3단계 핸드셰이크 방식을 사용하는 경우가 많다.
*실패 시나리오*
1. **첫 번째 시나리오**:
	- 클라이언트가 x를 선택하고 `req_conn(x)`를 전송한다.
	- 클라이언트는 응답이 지연되거나 손실된다고 판단하여 `req_conn(x)`를 재전송한다.
	- 서버는 `acc_conn(x)`로 응답하지만, 클라이언트는 연결을 종료한다.
	- 서버는 연결이 완료되었다고 판단하지만, 실제로는 클라이언트가 존재하지 않는 상태(반 열린 연결)가 된다.

2. **두 번째 시나리오**:
	- 클라이언트가 x를 선택하고 `req_conn(x)`를 전송한다.
	- 클라이언트는 응답이 지연되거나 손실된다고 판단하여 데이터 `data(x+1)`를 재전송한다.
	- 서버는 `acc_conn(x)`로 응답하고, 클라이언트는 데이터 `data(x+1)`를 수신하여 연결이 완료된다고 판단한다.
	- 그러나 서버는 연결 요청 `req_conn(x)`에 대한 기록을 잊어버려, 데이터를 수신한 후에도 클라이언트의 초기 연결 요청을 기다리는 상태가 된다.

이 시나리오들은 네트워크의 지연, 메시지 손실, 메시지 순서의 혼란 등 다양한 이유로 인해 발생할 수 있다. 이를 해결하기 위해 통상적으로는 더 안정적인 3단계 핸드셰이크를 사용하는 것이 권장된다.

## TCP *3단계 핸드셰이크* (TCP 3-Way Handshake)
- 클라이언트 상태
	- 초기 상태: CLOSED
	- 초기 시퀀스 번호 x 선택 후 TCP SYN 메시지 전송
	- 상태 변화: SYN SENT → ESTAB
	- SYNACK(x) 수신: 서버가 동작 중임을 표시, SYNACK에 대한 ACK 전송, 이 세그먼트는 클라이언트에서 서버로의 데이터를 포함할 수 있음

- 서버 상태
	- 초기 상태: LISTEN
	- 초기 시퀀스 번호 y 선택 후 TCP *SYNACK* 메시지 전송(SYN=1, ACK=1), SYN을 확인함
	- 상태 변화: SYN RCVD → ESTAB
	- ACK(y) 수신: 클라이언트가 동작 중임을 표시

### 추가 설명

TCP 3단계 핸드셰이크는 네트워크에서 연결의 신뢰성을 보장하기 위해 사용되는 방법이다. 이 과정은 다음과 같이 세 단계로 이루어진다:

1. **SYN 전송**: 클라이언트는 서버에게 연결을 요청하는 SYN 패킷을 보낸다. 이 패킷은 연결 요청과 함께 클라이언트의 초기 시퀀스 번호(x)가 포함되어 있다.
2. **SYNACK 응답**: 서버는 클라이언트의 SYN을 받고, SYN과 ACK을 모두 설정한 SYNACK 패킷을 클라이언트에게 보낸다. 이 패킷은 서버의 초기 시퀀스 번호(y)와 클라이언트의 시퀀스 번호에 1을 더한 값(x+1)을 ACK 번호로 사용한다.
3. **ACK 확인**: 클라이언트는 서버의 SYNACK 패킷을 받고, 이를 확인하는 ACK 패킷을 서버에 보낸다. 이 패킷은 서버의 시퀀스 번호에 1을 더한 값(y+1)을 ACK 번호로 포함한다.

이 과정을 통해 두 시스템은 서로의 존재와 준비 상태를 확인하고, 안정적으로 데이터를 교환할 수 있는 연결을 성립한다. 이는 데이터의 손실이나 순서 문제 등을 효과적으로 방지하여 통신의 신뢰성을 높인다.


## TCP 3단계 핸드셰이크: FSM-유한 상태 기계 (TCP 3-Way Handshake: FSM)
- 서버
	- 초기 상태: CLOSED
	- `welcomeSocket.accept();` 실행 후 상태 변화: LISTEN
	- SYN(x) 수신, SYNACK(seq=y, ACKnum=x+1) 전송, 클라이언트로의 응답을 위한 새 소켓 생성
	- 상태 변화: SYN RCVD
	- ACK(ACKnum=y+1) 수신 후 상태
- 클라이언트
	- 초기 상태: CLOSED 
	- `newSocket("hostname", "port number");` 실행 후 SYN(seq=x) 전송
	- 상태 변화: SYN SENT
	- SYNACK(seq=y, ACKnum=x+1) 수신, ACK(ACKnum=y+1) 전송
	- 상태 변화: ESTAB

### 추가 설명

TCP 3단계 핸드셰이크 과정은 유한 상태 기계(FSM)를 사용하여 모델링할 수 있다. 이 기계는 각 상태(예: CLOSED, LISTEN, SYN SENT, SYN RCVD, ESTAB)와 이 상태들 사이의 전이를 명확하게 표현한다. 각 전이는 네트워크 패킷의 수신이나 송신에 의해 트리거된다.

- **서버**는 CLOSED 상태에서 시작하여 `welcomeSocket.accept();`를 호출함으로써 LISTEN 상태로 이동한다. 이후 클라이언트로부터 SYN 패킷을 수신하면 SYN RCVD 상태로 전환되고, 클라이언트에게 SYNACK 패킷을 보낸다. 서버가 클라이언트로부터 ACK를 수신하면 최종적으로 ESTAB 상태가 되어 연결이 확립된다.

- **클라이언트**는 CLOSED 상태에서 시작하여 서버에 연결하기 위해 `newSocket("hostname", "port number");`를 호출하고 SYN 패킷을 전송하여 SYN SENT 상태로 전환한다. 서버로부터 SYNACK를 수신하면, 필요한 ACK를 전송하고 ESTAB 상태로 전환하여 연결이 확립된다.

이 모델은 TCP 연결이 어떻게 단계적으로 설정되는지를 명확하게 보여주며, 각 단계에서 어떤 프로토콜 메시지가 교환되는지를 설명한다. 이런 방식으로 TCP는 네트워크 상에서 데이터를 안정적으로 전송할 수 있는 견고한 연결을 제공한다.

## TCP: 연결 종료
- 클라이언트와 서버는 각자의 연결을 종료한다.
	- FIN 비트가 1인 TCP 세그먼트를 전송한다.
	- 수신한 FIN에 대해 ACK로 응답한다.
	- FIN을 받은 후, ACK는 자신의 FIN과 함께 결합될 수 있다.
	- 동시에 이루어지는 FIN 교환을 처리할 수 있다.

![240507-174238w](/posts/240507-174238.png)

- 클라이언트 상태
	- ESTAB에서 시작
	- `clientSocket.close()` 실행: 더 이상 데이터를 전송할 수 없지만 데이터 수신은 가능
	- FIN_WAIT_1: 서버의 종료를 기다림 - 서버가 Acknum=x+1을 보내면 FIN_WAIT_2로 전환
	- FIN_WAIT_2: 서버의 종료를 기다림 - 서버가 FIN을 보내면 TIMED_WAIT로 전환
	- TIMED_WAIT: 최대 세그먼트 수명의 2배 시간 동안 대기 - 서버에게 ACKnum=y+1을 보낸 후 세그먼트 생명주기의 2배 이후 CLOSED로 전환
	- CLOSED: 연결 종료

- 서버 상태
	- ESTAB에서 시작
	- `clientSocket.close()` 수신 -> CLOSE_WAIT: 여전히 데이터를 전송할 수 있음
	- LAST_ACK: 더 이상 데이터를 전송할 수 없음 - 클라이언트에게 Seq=y 전송
	- 클라이언트에게 ACKnum 수신 -> 즉시 CLOSED: 연결 종료
	
### 추가 설명
TCP 연결을 종료하는 과정은 연결을 설정하는 과정만큼 중요하다. 이 과정은 데이터 전송이 완료된 후에 안정적으로 연결을 마무리 지어 자원을 해제하는 데 필요하다.

1. **FIN 비트 전송**: 연결을 종료하려는 각 단말은 FIN 비트가 설정된 TCP 세그먼트를 상대방에게 전송한다. 이는 연결의 한 방향을 종료하겠다는 의도를 나타낸다.
2. **ACK 응답**: 수신 단말은 FIN 세그먼트를 받고, 이에 대해 ACK를 전송하여 수신을 확인한다. 또한, 수신 단말이 아직 보내지 않은 데이터가 있을 경우, 자신의 FIN 세그먼트와 함께 ACK를 전송할 수 있다.
3. **동시 종료 처리**: 두 단말이 거의 동시에 FIN 세그먼트를 보낼 경우, 각 단말은 상대방의 FIN에 대해 ACK를 보내며 이를 처리한다.

이 과정은 네트워크 상의 데이터 손실 없이 깔끔하게 연결을 종료하기 위해 설계되었다. 동시에 이루어지는 FIN 교환은 TCP 프로토콜이 복잡한 네트워크 상황에서도 연결을 효과적으로 종료할 수 있도록 보장한다. 이러한 메커니즘은 네트워크 자원의 효율적인 관리와 안정적인 네트워크 운영을 지원한다.
	

TCP 연결 종료 과정은 클라이언트와 서버 각각의 상태 변화를 통해 관리된다. 이 과정은 다음과 같은 단계를 포함한다:

1. **FIN_WAIT_1**: 클라이언트가 연결을 종료하고자 할 때 `FIN` 패킷을 전송하고, FIN_WAIT_1 상태로 전환한다.
2. **CLOSE_WAIT**: 서버가 클라이언트로부터 `FIN` 패킷을 받고, 이에 대한 `ACK`를 보낸 후 CLOSE_WAIT 상태로 전환한다. 이 상태에서 서버는 클라이언트에게 마지막 데이터를 전송할 수 있다.
3. **LAST_ACK**: 서버가 모든 데이터 전송을 완료하고 자신의 `FIN` 패킷을 클라이언트에게 보내면, LAST_ACK 상태로 전환한다.
4. **FIN_WAIT_2**: 클라이언트는 서버의 `FIN` 패킷을 기다리는 동안 FIN_WAIT_2 상태에 있다.
5. **TIMED_WAIT**: 클라이언트는 서버로부터 `FIN`을 받고, 이에 대한 `ACK`를 보낸 후 TIMED_WAIT 상태로 전환된다. 이 상태에서 일정 시간(보통 최대 세그먼트 수명의 2배)을 대기하여, 네트워크 지연으로 인한 패킷 손실이 없는지 확인한다.
6. **CLOSED**: 양쪽 모두 `CLOSED` 상태로 전환되며, 연결이 완전히 종료된다.

이 단계들은 TCP 연결이 완전히 정리되고 모든 자원이 해제될 때까지 관리되어 네트워크 상의 자원 사용을 최적화하며 데이터 손실을 방지한다.

# 3.6 혼잡 제어 원칙 (Principles of Congestion Control)
## 혼잡 제어의 원칙 (Principles of Congestion Control)
- 혼잡:
	-  비공식적으로: "네트워크가 처리할 수 있는 것보다 너무 많은 소스에서 너무 빠르게 데이터를 보냄"
- 흐름 제어와는 다름!
- 현상:
	- 분실된 패킷(라우터에서의 버퍼 오버플로우)
	- 긴 지연(라우터 버퍼에서의 큐잉)
- 10대 문제 중 하나!

- 혼잡을 감지하는 방법은?
- 혼잡이 감지되었을 때의 대응 방법은?

### 추가 설명

혼잡 제어는 네트워크에서 중요한 과제 중 하나이며, 특히 대규모 데이터를 전송하는 환경에서 중요하다. 이는 다음과 같은 두 가지 주요 문제로 나타난다:

1. **분실된 패킷**: 많은 데이터 패킷이 동시에 네트워크로 전송될 때, 라우터의 버퍼 용량이 초과되어 일부 패킷이 분실될 수 있다. 이는 데이터 전송의 신뢰성을 저하시키며, 통신 효율성을 크게 떨어뜨린다.
2. **긴 지연 시간**: 네트워크의 트래픽이 라우터의 처리 용량을 초과할 경우, 패킷은 큐에서 대기해야 하며 이로 인해 전송 지연이 발생한다.

혼잡을 감지하는 방법으로는 네트워크의 패킷 손실율과 지연 시간을 측정하는 것이 포함된다. 혼잡이 감지되면, 데이터 전송 속도를 조정하거나, 데이터의 우선 순위를 재정렬하는 등의 조치를 취할 수 있다. 이러한 조치들은 네트워크의 효율을 개선하고, 데이터 전송의 신뢰성을 보장하기 위해 필수적이다.

## 혼잡의 원인 및 비용: 시나리오 1 (Causes and Costs of Congestion: Scenario 1)
  - 두 발신자, 두 수신자
  - 하나의 라우터, 무한 버퍼 -> no packet loss
  - 출력 링크 용량: R
  - 재전송 없음
  - 무제한 공유 출력 링크 버퍼

### 추가 설명

이 시나리오는 네트워크에서의 혼잡 현상과 그 비용을 설명하고 있다. 주요 요소는 다음과 같다:

1. **데이터 전송**: 두 호스트(A와 B)가 데이터를 라우터를 통해 다른 두 호스트(C와 D)에게 전송한다. 각 호스트는 원본 데이터($\lambda_{in}$)를 발신하며, 이 데이터는 라우터를 통해 처리된다.

2. **라우터 용량과 버퍼**: 라우터는 무한 버퍼를 가지고 있으며, 출력 링크의 용량은 R로 제한되어 있다. 이는 네트워크의 출력 링크에서 데이터가 처리될 수 있는 최대 속도를 의미한다.

3. **처리량과 지연**: 그래프는 입력 데이터의 도착률($\lambda_{in}$)에 따른 출력 데이터의 처리량($\lambda_{out}$)과 지연을 나타낸다. 도착률이 R/2에 도달할 때까지는 처리량이 선형적으로 증가하다가 그 이후로는 포화 상태에 도달하여 처리량이 일정하게 유지된다. 반면, 지연은 도착률이 R/2를 초과함에 따라 급격히 증가한다.

이 시나리오는 네트워크에서 데이터 도착률이 라우터의 처리 용량에 근접하거나 초과할 때 발생하는 혼잡과 그로 인한 지연을 보여준다. 혼잡이 발생하면, 라우터 버퍼에 데이터가 쌓이기 시작하고, 이로 인해 패킷 지연이 증가하며 네트워크 성능이 저하될 수 있다. 이는 네트워크 설계와 관리에서 중요한 고려사항이다.


## 혼잡의 원인 및 비용: 시나리오 2 (Causes and Costs of Congestion: Scenario 2)
  - 하나의 라우터, 유한 버퍼
  - 발신자는 시간 초과된 패킷을 재전송한다.
    - 응용 계층 입력 = 응용 계층 출력: $\lambda_{in} = \lambda_{out}$
    - 전송 계층 출력은 재전송을 포함한다: $\lambda'_{in} \geq \lambda_{in}$

### 추가 설명

이 시나리오는 유한 버퍼를 가진 네트워크 라우터와 관련된 혼잡의 복잡성을 설명한다. 여기에는 다음과 같은 요소가 포함된다:

1. **재전송 메커니즘**: 패킷 전송 실패 또는 시간 초과로 인한 패킷 손실이 발생하면, 발신자는 해당 패킷을 재전송한다. 이는 전송 계층에서 처리되며, 이로 인해 네트워크에 전송되는 총 데이터량이 증가한다.

2. **유한 버퍼**: 라우터의 버퍼가 유한하다는 것은 네트워크 트래픽이 라우터의 버퍼 용량을 초과할 경우 패킷이 버려지게 됨을 의미한다. 이러한 상황은 네트워크 성능을 저하시키고, 더 많은 재전송을 필요로 하게 된다.

3. **입력과 출력의 관계**: 이 시나리오에서는 응용 계층의 입력과 출력이 동일하다고 가정한다. 즉, 응용 계층에서 네트워크로 전송되는 데이터의 양은 라우터를 통해 전송되어야 하는 데이터의 양과 같다. 그러나 전송 계층의 출력은 재전송된 데이터를 포함하기 때문에 실제 라우터를 통과하는 데이터량은 더 많아진다.

이 시나리오는 유한한 자원을 가진 네트워크에서 재전송으로 인해 발생할 수 있는 혼잡 문제를 잘 보여준다. 재전송은 필요한 경우에만 수행되어야 하며, 네트워크 설계와 운영에서는 이를 최소화하기 위한 전략이 중요하다. 혼잡 제어 메커니즘은 네트워크의 버퍼 용량과 트래픽 패턴을 고려하여 효율적으로 구현되어야 한다.


## 혼잡의 원인 및 비용: 시나리오 2-1 (Causes and Costs of Congestion: Scenario 2-1)
- 이상화-1: 완벽한 지식
	- 발신자는 라우터 버퍼에 공간이 있을 때만 데이터를 전송한다.

### 추가 설명

이 시나리오는 이상적인 네트워크 상황에서의 혼잡 제어 방법을 설명하며, 발신자가 라우터의 버퍼 상태에 대한 완벽한 지식을 가지고 있을 때의 데이터 전송 방식을 보여준다. 주요 특징은 다음과 같다:

1. **완벽한 버퍼 관리**: 발신자는 라우터의 버퍼에 충분한 공간이 있을 때만 데이터를 전송한다. 이는 네트워크의 혼잡을 방지하고, 데이터 패킷의 손실을 최소화하는 데 도움이 된다.

2. **데이터 전송 및 재전송**: 원본 데이터($\lambda_{in}$)와 재전송되는 데이터($\lambda'_{in}$)가 모두 포함되어 있음에도 불구하고, 버퍼의 이용 가능성에 따라 전송이 이루어진다는 점에서, 라우터의 효율적인 운용이 가능하다.

3. **처리량 그래프**: 제시된 그래프에서는 입력 데이터의 도착률($\lambda_{in}$)이 증가함에 따라 출력 데이터의 처리량($\lambda_{out}$)이 선형적으로 증가하다가 R/2에서 포화 상태에 도달하는 것을 보여준다. 이는 라우터가 처리할 수 있는 최대 용량을 나타낸다.

이 시나리오는 이상적인 혼잡 제어 상황을 가정하며, 실제 네트워크 환경에서 이러한 조건을 완벽하게 구현하기는 어려울 수 있다. 그러나, 이러한 접근 방식은 네트워크 설계와 관리에서 혼잡을 줄이고 전체적인 성능을 개선하기 위한 중요한 기준을 제공한다. 이는 네트워크 리소스의 효율적 사용과 지연 시간의 최소화를 위해 중요하다.


## 혼잡의 원인 및 비용: 시나리오 2-2
- 이상화-2: 알려진 손실 패킷
	- 패킷이 버퍼가 가득 차서 라우터에서 손실될 수 있음
	- 발신자는 패킷이 분실되었다는 것을 알 때만 재전송함

### 추가 설명

이 시나리오는 네트워크 혼잡 상황에서 패킷 손실을 관리하는 방법을 설명하며, 발신자가 패킷 손실에 대한 정보를 알고 있을 때의 대응 전략을 보여준다. 주요 요소는 다음과 같다:

1. **버퍼 손실**: 라우터의 버퍼가 가득 차 있을 때 추가 패킷이 도착하면, 새로운 패킷은 버려지거나 드랍된다. 이는 네트워크의 처리 능력이 한계에 도달했음을 의미한다.

2. **재전송 전략**: 발신자는 패킷이 손실되었다는 명확한 피드백(예: 확인 응답 미수신, 명시적 손실 통지 등)을 받았을 때만 해당 패킷을 재전송한다. 이는 불필요한 재전송을 방지하고, 네트워크 자원의 효율적 사용을 도모한다.

3. **네트워크 효율성**: 알려진 패킷 손실 정보를 통해 발신자는 네트워크 상태를 더 잘 이해하고, 데이터 전송을 보다 효율적으로 조절할 수 있다. 이는 전체적인 네트워크 성능을 개선하고, 혼잡으로 인한 비용을 줄이는 데 기여한다.

이 시나리오는 혼잡 제어 메커니즘에서 발신자와 라우터 간의 상호작용을 강조하며, 정보에 기반한 의사결정이 네트워크의 안정성과 성능에 어떤 영향을 미칠 수 있는지를 보여준다. 이러한 접근 방식은 특히 대규모 데이터 전송이 이루어지는 환경에서 중요하며, 패킷 손실과 지연을 최소화하기 위해 중요한 전략이다.

## 혼잡의 원인 및 비용: 시나리오 2-3
- 현실적: 중복 발생 가능
	- 패킷은 버퍼가 가득 차서 라우터에서 분실될 수 있음 → 타임아웃이 필요함.
	- 발신자가 조기에 타임아웃되어 두 개의 복사본을 보내고, 두 복사본 모두 전달됨.

### 추가 설명

이 시나리오는 네트워크 혼잡 시 발생할 수 있는 패킷 중복 전송 문제와 그로 인한 비용을 설명한다. 이는 다음과 같은 여러 요소를 포함한다:

1. **패킷 손실과 재전송**: 라우터의 버퍼가 가득 찼을 때 패킷이 손실될 수 있고, 이로 인해 발신자는 타임아웃 후에 해당 패킷을 재전송한다. 하지만, 원본 패킷이 지연되어 나중에 도착하는 경우가 발생할 수 있으며, 결과적으로 중복 패킷이 네트워크를 통해 전송될 수 있다.

2. **중복의 비용**: 재전송된 패킷들이 네트워크를 통과하는 동안, 이들은 불필요한 네트워크 자원을 사용하고, 전체적인 네트워크 성능을 저하시킬 수 있다. 특히, 두 복사본 모두가 전달되면 네트워크의 처리량(throughput)에 영향을 미치지만 실제로 유용한 데이터 전송량(goodput)은 감소한다.

3. **혼잡의 비용**: 이러한 중복 전송은 네트워크의 혼잡을 증가시키며, 이로 인해 더 많은 재전송이 필요하게 될 수 있다. 이는 전체적으로 네트워크의 효율성을 떨어뜨리는 결과를 초래한다.

시나리오 2-3은 네트워크 설계와 관리에서 중복 패킷을 최소화하기 위한 전략이 얼마나 중요한지를 보여준다. 이를 통해 네트워크 리소스를 보다 효율적으로 관리하고, 전체적인 네트워크 성능을 개선할 수 있는 방법을 모색할 수 있다.

## 혼잡의 원인 및 비용: 시나리오 3
- 네 발신자, 멀티홉 경로
- 타임아웃/재전송
- 질문: $\lambda_{in}$ 및 $\lambda'_{in}$이 증가함에 따라 어떤 일이 발생하는가?
- 답변: 빨간색 $\lambda'_{in}$이 증가함에 따라 상단 큐에 도착하는 모든 파란색 패킷이 드롭되고, 파란색 처리량은 거의 0에 가까워진다.

### 추가 설명

이 시나리오는 네트워크의 여러 발신자와 복잡한 전송 경로를 통한 데이터의 이동과 혼잡의 영향을 보여준다. 주요 요소는 다음과 같다:

1. **데이터 흐름과 혼잡**: 여러 발신자가 데이터를 보내면서 네트워크의 특정 부분, 특히 공유 출력 링크의 버퍼가 포화 상태에 이르게 된다. 이 경우 $\lambda'_{in}$ (원본 데이터와 재전송 데이터를 합친 양)이 증가함에 따라, 처리량이 급격히 감소하고, 패킷 손실이 발생하기 시작한다.

2. **패킷 손실과 처리량 감소**: 시나리오에서 보여주는 그래프는 입력률이 증가함에 따라 초기에는 처리량이 증가하지만, 특정 지점(C/2)을 초과하면 급격히 감소함을 나타낸다. 이는 버퍼 오버플로우로 인해 발생하는 패킷 드롭 때문이다.

3. **비용**: 패킷이 드롭될 때, 그 패킷을 전송하기 위해 사용된 모든 상류 네트워크 자원(대역폭, 라우터 처리 시간 등)은 낭비된다. 이는 네트워크의 전반적인 효율성을 저하시키며, 필요 이상의 재전송으로 인해 네트워크 혼잡을 가중시킬 수 있다.

이 시나리오는 네트워크 설계자들이 혼잡 제어 메커니즘을 효과적으로 구현하여, 높은 트래픽 상황에서도 네트워크 성능을 최적화할 수 있도록 중요한 통찰을 제공한다. 패킷 드롭과 재전송 최소화는 네트워크 성능을 유지하고 비용을 절감하는 데 필수적인 요소이다.

# 3.7 TCP 혼잡 제어 (TCP Congestion Control)
## 핵심 질문
- 혼잡 제어를 하고자 한다.
	- 혼잡이 있을 경우, 전송률을 감소시켜 혼잡을 피하거나 완화, 제거한다.
	- 혼잡이 없을 경우, 전송률을 증가시켜 대역폭을 더 잘 활용한다.

- 주요 질문들
	- '전송률'을 어떻게 제어할까?
		- 전송률을 증가시키거나 감소시키는 메커니즘
	- 혼잡을 어떻게 감지할까?
		- 혼잡을 감지하거나 유추하는 메커니즘
	- 전송률을 얼마나, 언제 증가시키거나 감소시킬까?
		- 제어 알고리즘

- 참고: 우리는 TCP의 한 버전인 TCP Reno의 주요 특징만을 살펴볼 것이다.
	- TCP에는 여기서 논의할 것보다 훨씬 많은 내용이 있다.

### 추가 설명

혼잡 제어는 네트워크의 효율적인 운영을 위해 매우 중요한 부분이다. 특히, TCP Reno는 TCP의 대표적인 버전 중 하나로, 네트워크의 혼잡 상태를 관리하는 다음과 같은 방법을 포함한다:

1. **전송률 제어**: TCP Reno는 패킷 손실이 감지될 때 전송률을 감소시키는 메커니즘을 사용한다. 일반적으로 패킷 손실은 네트워크의 혼잡을 나타내므로, 전송률을 줄임으로써 추가 혼잡을 방지하려고 한다.

2. **혼잡 감지**: TCP Reno는 주로 패킷 손실을 통해 혼잡을 감지한다. 손실된 패킷은 타임아웃이 발생하거나, 잘못된 순서로 패킷이 도착하는 것을 통해 감지된다.

3. **전송률 조정**: 전송률은 혼잡 윈도우를 통해 조절된다. 혼잡 윈도우는 네트워크의 상태에 따라 동적으로 조절되며, 이를 통해 네트워크의 처리량과 성능을 최적화한다.

TCP Reno와 같은 프로토콜은 네트워크에서 데이터를 효과적으로 전송하기 위해 설계된 다양한 알고리즘과 전략을 포함하고 있다. 이러한 메커니즘을 이해하고 적절히 적용하는 것은 네트워크 성능을 최대화하고, 사용자 경험을 향상시키는 데 필수적이다.

## TCP 혼잡 제어의 핵심 용어
- 주요 상태 및 메커니즘
	- "slow start" - 전송률의 지수적 증가
	- "congestion avoidance" - "AIMD(Additive Increase/Multiplicative Decrease)"
	- "fast recovery" - 빠른 회복

- 주요 파라미터
	- 혼잡 윈도우: cwnd
	- 슬로우 스타트 임계값: ssthresh
	- MSS, RTT

- 주요 이벤트
	- "ACK received" - 모든 것이 잘 진행되고 있음을 의미
	- "timeout" - 매우 나쁜 상황을 의미
	- "3 duplicate ACK received" - 나쁜 상황이지만 타임아웃만큼은 아님

### 추가 설명

TCP의 혼잡 제어 메커니즘은 네트워크의 효율성을 최대화하고 패킷 손실을 최소화하기 위해 설계되었다. 여기에는 여러 중요한 개념과 파라미터가 있다:

1. **Slow Start**: 연결 초기에 데이터 전송률을 천천히 증가시켜 혼잡 가능성을 최소화한다. 시작 시 혼잡 윈도우(cwnd)는 일반적으로 하나의 세그먼트 크기(MSS)로 설정되며, ACK가 수신될 때마다 이 윈도우는 두 배씩 증가한다.

2. **Congestion Avoidance**: 네트워크가 혼잡해지기 시작하면, 전송률을 점진적으로 증가시키는 AIMD 접근 방식을 사용한다. 데이터 패킷이 성공적으로 전송되면 cwnd는 점진적으로 증가하고, 패킷 손실이 감지되면 크게 감소한다.

3. **Fast Recovery**: 세 개의 중복 ACK이 수신되면, 이는 네트워크에서 패킷 손실이 발생했으나 경로는 여전히 활성화되어 있음을 나타낸다. 이 경우, TCP는 타임아웃을 기다리지 않고 즉시 재전송을 시작한다.

이러한 메커니즘은 네트워크 상황을 신속하게 파악하고 적절히 대응하여 데이터 흐름을 유지하며, 전체적인 네트워크 성능을 개선하는 데 도움을 준다. 각 상태와 이벤트는 TCP 연결의 건전성과 효율성을 유지하는 데 중요한 역할을 한다.

## TCP 혼잡 윈도우
  - 발신자는 전송을 제한한다:
    - 마지막으로 보낸 바이트 - 마지막으로 확인된 바이트 < = cwnd
  - cwnd는 동적이며, 네트워크 혼잡을 감지하는 함수다.
  - TCP 전송률:
    - 대략적으로: cwnd 바이트를 보내고, RTT 동안 ACK를 기다린 후 더 많은 바이트를 보낸다.
    - 전송률 ≈ cwnd / RTT 바이트/초

### 추가 설명

TCP에서 혼잡 윈도우(cwnd)는 네트워크의 혼잡 상태를 기반으로 조절되는 중요한 파라미터이다. 이 윈도우는 발신자가 네트워크를 통해 "in-flight" 상태, 즉 아직 확인되지 않은 상태로 전송할 수 있는 데이터의 최대 양을 결정한다.

1. **혼잡 윈도우의 역할**:
   - 혼잡 윈도우는 네트워크의 전송 능력과 직접적으로 관련이 있어, 네트워크의 성능을 최적화하고 패킷 손실을 방지하는 데 사용된다.
   - cwnd의 크기에 따라 TCP는 데이터를 얼마나 빨리 보낼 수 있는지 결정된다. 네트워크 상황이 좋을 때 cwnd는 증가하여 더 많은 데이터를 보낼 수 있으며, 네트워크 혼잡이 감지될 때는 감소한다.

2. **전송률 계산**:
	- TCP의 전송률은 혼잡 윈도우 크기와 왕복 시간(RTT)에 따라 결정된다. 이 비율은 네트워크의 처리량을 결정하며, 이론적으로는 `cwnd / RTT`와 같다.
	- 이 계산은 혼잡 윈도우가 네트워크의 현재 상태를 어떻게 반영하고 있는지를 나타내며, RTT 동안 전송되고 확인될 수 있는 데이터의 양을 제한한다.

혼잡 윈도우의 관리는 TCP의 성능을 최적화하는 데 중요하며, 이는 네트워크 혼잡을 효과적으로 관리하고 데이터 전송률을 적절하게 조절함으로써 보다 효율적인 네트워크 운영을 가능하게 한다.

## TCP 슬로우 스타트
- 연결이 시작될 때, 첫 번째 손실 이벤트까지 전송률을 지수적으로 증가시킨다:
	- 초기 혼잡 윈도우(cwnd) = 1 MSS
	- 각 RTT마다 혼잡 윈도우를 두 배로 증가
		- 각 수신된 ACK마다 cwnd를 증가시킴
- 초기 전송률은 느리지만, 매우 빠르게 증가
- 모든 ‘타임아웃’ 이벤트 이후에 슬로우 스타트로 돌아감
- 모든 ‘3중 중복 ACK’ 이벤트 이후에 혼잡 회피로 이동

### 추가 설명

TCP 슬로우 스타트는 연결 초기에 네트워크의 혼잡 상태를 천천히 탐색하면서 전송률을 조절하는 방법입니다. 이 접근 방식의 목적은 네트워크 용량을 초과하지 않으면서 점진적으로 전송량을 늘리는 것입니다.

1. **지수적 증가**: 연결 시작 시, cwnd는 하나의 최대 세그먼트 크기(MSS)로 설정되고, 각 RTT마다 혼잡 윈도우 크기는 이전 크기의 두 배로 증가합니다. 이는 네트워크의 처리량을 빠르게 증가시키는 효과가 있지만, 네트워크의 한계를 빠르게 도달할 수도 있습니다.

2. **혼잡 감지 후 조치**: 첫 번째 패킷 손실(타임아웃)이 감지되면, TCP는 혼잡 윈도우를 초기화하고 다시 슬로우 스타트 단계로 돌아갑니다. 이는 네트워크의 혼잡 상태를 재평가하고 더 안정적인 전송률을 찾기 위함입니다.

3. **혼잡 회피 단계**: 세 번의 중복된 ACK 수신은 네트워크 내 일부 경로에서 패킷 손실이 발생했으나 네트워크 연결이 여전히 유효함을 의미합니다. 이 경우 TCP는 혼잡 회피 단계로 전환하여 혼잡 윈도우의 크기를 보수적으로 조정합니다.

이러한 메커니즘을 통해 TCP는 네트워크의 혼잡 상태를 효과적으로 관리하고, 데이터 전송의 신뢰성과 효율성을 높이는데 기여합니다.

