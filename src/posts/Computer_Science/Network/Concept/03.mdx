# 3.5 연결 지향 전송: TCP (Connection-Oriented Transport: TCP)
## TCP 개요
- **연결 지향적**(Connection-Oriented)
	- 악수(handshake, 제어 메시지 교환)은 데이터 교환 전 송수신자의 상태/매개변수를 초기화함
	- 논리적인 종단 간 연결이며, 전화 회선처럼 실제 회로는 아님
		- 네트워크 내부에 상태/연결 정보 없음
- 일대일 통신
	- 한 송신자, 한 수신자
- 전이중 데이터
	- 같은 연결에서 양방향 데이터 흐름
- 흐름 제어
	- 수신자가 송신자의 속도에 맞춰 데이터를 받을 수 있도록 함
	- 송신자가 수신자를 압도하지 않음
- 신뢰할 수 있는, 순서대로 정렬된 바이트 스트림
	- 메시지 경계가 없다
	- 메시지를 분할하여 **TCP 세그먼트**를 사용하여 전송
		- MSS(Maximum Segment Size): 한 번에 전송할 수 있는 최대 데이터 크기
- 파이프라인 방식
	- TCP 혼잡 및 흐름 제어가 윈도우 크기 결정 = **min(flow control, congestion control)** -> dynaminc/adaptive

## TCP 연결의 여러 종류 (Many Flavors of TCP)
Taho->**(New)Reno**->Vegas->Westwood->Binary Increase Congestion control(BIC)->**Cubic**->**BBR**
- new Reno: 거의 모든 OS에서 기본적으로 사용되는 전통적인 TCP
- Cubic: 리눅스에서 기본적으로 사용되는 TCP
- BBR: 구글에서 개발한 TCP, 가장 빠른 속도를 보임

혼잡 제어 알고리즘(congestion control algorithm)의 가장 큰 차이점? -> **congestion window size**의 변화

## TCP 세그먼트 구조 (TCP Segment Structure)
- 헤더: 20바이트
	- souce port(16bit), destination port(16bit)
	- sequence number(32bit): DATA의 순서 - 32bit
	- acknowledgment number(32bit): ACK 번호 - 32bit
	- SYN: 연결 설정 요청
	- FIN: 연결 종료 요청
	- ACK valid bit(1bit): ACK 번호가 유효한지
	- receive window(16bit): 수신자가 받을 수 있는 데이터 크기 -> flow control
	- checksum(16bit): 오류(biterror) 검출
	- options(0~40byte): 옵션 정보
- payload(데이터): 최대 65,535바이트

## TCP 시퀀스 번호, ACK 번호 (TCP Sequence Number, ACK Number)
예시: 500kb 메시지를 보낼 때, MSS=1000bytes
500kb = 500,000bytes = 500개의 세그먼트

시퀀스 번호: 각 세그먼트의 첫 번째 바이트의 **바이트 스트림 번호** - 0, 1000, 2000, 3000, 4000
ACK 번호: 수신자가 **다음에 받을 세그먼트**의 시퀀스 번호 - 1000, 2000, 3000, 4000, 5000
### 특징
- 패킷은 시퀀스 번호와 ACK 번호를 모두 가지고 있다
	- 데이터 패킷을 ACK 용으로 사용 가능
	- 전이중 통신 가능 (full-duplex)
- 실제로는 0부터 시작하지 않음
	- 초기 시퀀스 번호는 랜덤하게 선택됨. 왜일까? -> 새로운 패킷을 보낼 때마다 시퀀스 번호가 0부터 시작하면, 이전에 보낸 패킷과 중복될 수 있기 때문
- 시작 번호를 알 수 있는 방법
	- 3-way handshake: 초기 시퀀스 번호를 알려줌
- 수신자가 순서가 어긋난 패킷을 받았을 때
	- TCP에서 명시하지 않음

### 예시
- 사용자가 'C'를 입력한다.
- 호스트 A는 시퀀스 번호 42, 인정 번호 79, 데이터 'C'를 가진 패킷을 전송한다.
- 호스트 B는 'C'의 수신을 인정하고 'C'를 에코(반사)로 돌려보낸다.
- 호스트 B는 시퀀스 번호 79, 인정 번호 43, 데이터 'C'를 가진 패킷을 전송한다.
	- 시퀀스 번호 79: A가 보낸 ACK
	- 인정 번호 43: A가 보낸 Seq + 1
- 호스트 A는 'C'의 수신을 인정하고 시퀀스 번호 43, 인정 번호 80을 가진 패킷을 전송한다.
	- 시퀀스 번호 43: B가 보낸 ACK
	- 인정 번호 80: B가 보낸 Seq + 1

## TCP 왕복 시간, 타임아웃 (TCP Round-Trip Time, Timeout)
TCP 는 패킷 손실을 회복하기 위해 타임아웃 후 재전송한다.
- Timeout 값을 설정하는 법
	- RTT보다 길게 설정
		- RTT(Round-Trip Time): 패킷을 보내고 ACK를 받는 데 걸리는 시간
		- RTT는 변할 수 있다
	- 너무 짧으면: 성급한 타임아웃, 불필요한 재전송
	- 너무 길면: 세그먼트 손실에 대한 반응이 느림
	- 몇 개의 타이머가 필요한가
- RTT를 추정하는 방법
	- SampleRTT: 패킷(세그먼트)을 보내고 ACK를 받는 데 걸린 시간
		- 재전송은 무시. 왜? -> RTT가 길어지면 재전송이 빈번해질 수 있음
	- 변동성이 있으므로 여러 최근 측정치를 평균낸다.
- 지수 가중 이동 평균(Exponential Weighted Moving Average)
	> EstimatedRTT = (1-α) * EstimatedRTT + α * SampleRTT
	- 과거 샘플의 영향이 지수적으로 빠르게 감소함
		- $E'=(1-\alpha)\left\{(1-\alpha)E+\alpha S\right\} $
		- $E''=(1-\alpha)\left\{(1-\alpha)\left\{(1-\alpha)E+\alpha S\right\}+\alpha S\right\}$
		- ...
		- $E_n=(1-\alpha)E_{n-1}+\alpha S$
	- 일반적으로, α: 0.125
- 타임아웃 간격(TimeOut Interval): **추정된 RTT(EstimatedRTT)**에 "안전 마진"이 추가됨
	- 추정된 RTT의 변동이 크면 안전 마진도 커짐
	- DevRTT: RTT의 변동성
		> DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT|
		- 일반적으로, β: 0.25
	- TCP의 타임아웃 간격(TimeoutInterval) = 추정된 RTT(EstimatedRTT) + 4 * DevRTT(safety margin)

# 3.5(2) TCP: 신뢰할 수 있는 데이터 전송(Reliable Data Transfer)
## 신뢰할 수 있는 데이터 전송(Reliable Data Transfer)
- **IP가 불안정하다**
	- 데이터가 손상, 분실, 순서변경, 삭제될 수 있다.
- TCP는 IP의 불안정성을 보완한다
	- 받은 바이트 스트림은 보낸 것과 정확히 일치함
	- 사용법
		- 파이프라인 세그먼트
		- 시퀀스 번호, ACK 번호
		- 타임아웃, 재전송
	- 재전송은 다음에 의해 트리거됨
		- 타임아웃
		- 중복된 ack
## TCP 송신자 이벤트(TCP Sender Events)
1. 애플리케이션으로부터 데이터를 받음
	- 시퀀스 번호를 할당하고, 데이터를 세그먼트로 나눔
	- 타이머가 시작됨
2. 타임아웃
	- 타이머가 만료되면, 세그먼트를 재전송
	- 타이머 재설정
3. ACK 수신
	- ACK가 이전에 인정받지 않은 세그먼트 인정
		- ACKed로 업데이트
	- ACK가 이전에 인정받은 세그먼트를 인정
		- 중복 ACK

## TCP: 재전송 시나리오(TCP: Retransmission Scenario)
### 시나리오1
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 전송한다.
- 타임아웃 후, 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 재전송한다.
- 호스트 B는 ACK 100을 보낸다.
- 문제: 잃어버린 ACK 시나리오

### 시나리오2
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 전송하고, 이어서 시퀀스 번호 100, 20 바이트의 데이터를 전송한다.
- 호스트 B는 ACK 100과 ACK 120을 전송한다.
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 재전송한다.
- 호스트 B는 ACK 120을 다시 전송한다.
- 문제: 성급한 타임아웃 시나리오

### 시나리오3
- Host A는 시퀀스 번호 92로 8바이트의 데이터를 전송한다.
- 다음으로, 시퀀스 번호 100으로 20바이트의 데이터를 전송하지만, 이 데이터는 손실된다 (X로 표시).
- Host B는 시퀀스 번호 100의 데이터를 수신하지 못했기 때문에 ACK 100을 전송하여 이를 Host A에 알린다.
- 그 후, Host A는 시퀀스 번호 120으로 15바이트의 데이터를 전송하고, Host B는 ACK 120을 보낸다.
- 문제: 누적 ACK을 시나리오

## TCP ACK 생성(TCP ACK Generation)
- 수신자 이벤트: 순서대로 도착한 세그먼트가 예상 시퀀스 번호와 일치하며, 이전 모든 데이터는 이미 ACK이 완료된 상태다.
	- TCP 수신 액션: 지연된 ACK. 다음 세그먼트를 500ms 동안 기다린다. 다음 세그먼트가 없다면 ACK을 보낸다.
- 수신자 이벤트: 순서대로 도착한 세그먼트가 예상 시퀀스 번호와 일치하며, 다른 세그먼트에 대한 ACK이 대기 중이다.
	- TCP 수신 액션: 즉시 단일 누적 ACK을 보내어 순서대로 도착한 두 세그먼트를 모두 ACK한다.
- 수신자 이벤트: 예상보다 높은 시퀀스 번호를 가진 순서에 맞지 않는 세그먼트가 도착하며, 갭이 감지된다.
	- TCP 수신 액션: 즉시 중복 ACK을 보내어 다음 예상 바이트의 시퀀스 번호를 나타낸다.
- 수신자 이벤트: 갭을 부분적으로나 완전히 채우는 세그먼트가 도착한다.
	- TCP 수신 액션: 갭의 낮은 쪽에서 시작하는 세그먼트가 도착하면 즉시 ACK을 보낸다.

## TCP 빠른 재전송(TCP Fast Retransmit)
문제정의: 타임아웃 기간이 종종 상대적으로 김
아이디어: 중복 ACK을 통해 잃어버린 세그먼트를 식별하고, 즉시 재전송
	- 세그먼트가 손실되면, 중복 ACK이 많이 발생할 가능성이 있다.

TCP 빠른 재전송
	- 중복 ACK이 3개 이상 수신되면, 잃어버린 세그먼트로 간주하고 즉시 재전송
	- 가장 작은 시퀀스 번호를 가진 세그먼트를 재전송
	- 타임아웃을 기다리지 않음

예시)
- Host A는 시퀀스 번호 92에서 8바이트의 데이터를 전송하고, 이어서 시퀀스 번호 100에서 20바이트의 데이터를 전송한다.
- 시퀀스 번호 100의 데이터가 손실되었다는 표시(X)로 인해, Host B는 같은 시퀀스 번호에 대해 여러 번(3번) ACK 100을 반복해서 전송한다.
- Host A는 이 3중 중복 ACK을 받고, 손실된 시퀀스 번호 100의 데이터 20바이트를 즉시 재전송한다.