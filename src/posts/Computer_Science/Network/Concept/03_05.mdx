# 3.5.1 연결 지향 전송: TCP (Connection-Oriented Transport: TCP)
## TCP 개요
- **연결 지향적**(Connection-Oriented)
	- 악수(handshake, 제어 메시지 교환)은 데이터 교환 전 송수신자의 상태/매개변수를 초기화함
	- 논리적인 종단 간 연결이며, 전화 회선처럼 실제 회로는 아님
		- 네트워크 내부에 상태/연결 정보 없음
- 일대일 통신
	- 한 송신자, 한 수신자
- 전이중 데이터
	- 같은 연결에서 양방향 데이터 흐름
- 흐름 제어
	- 수신자가 송신자의 속도에 맞춰 데이터를 받을 수 있도록 함
	- 송신자가 수신자를 압도하지 않음
- 신뢰할 수 있는, 순서대로 정렬된 바이트 스트림
	- 메시지 경계가 없다
	- 메시지를 분할하여 **TCP 세그먼트**를 사용하여 전송
		- MSS(Maximum Segment Size): 한 번에 전송할 수 있는 최대 데이터 크기
- 파이프라인 방식
	- TCP 혼잡 및 흐름 제어가 윈도우 크기 결정 = **min(flow control, congestion control)** -> dynaminc/adaptive

## TCP 연결의 여러 종류 (Many Flavors of TCP)
Taho->**(New)Reno**->Vegas->Westwood->Binary Increase Congestion control(BIC)->**Cubic**->**BBR**
- new Reno: 거의 모든 OS에서 기본적으로 사용되는 전통적인 TCP
- Cubic: 리눅스에서 기본적으로 사용되는 TCP
- BBR: 구글에서 개발한 TCP, 가장 빠른 속도를 보임

혼잡 제어 알고리즘(congestion control algorithm)의 가장 큰 차이점? -> **congestion window size**의 변화

## TCP 세그먼트 구조 (TCP Segment Structure)
- 헤더: 20바이트
	- souce port(16bit), destination port(16bit)
	- sequence number(32bit): DATA의 순서 - 32bit
	- acknowledgment number(32bit): ACK 번호 - 32bit
	- SYN: 연결 설정 요청
	- FIN: 연결 종료 요청
	- ACK valid bit(1bit): ACK 번호가 유효한지
	- receive window(16bit): 수신자가 받을 수 있는 데이터 크기 -> flow control
	- checksum(16bit): 오류(biterror) 검출
	- options(0~40byte): 옵션 정보
- payload(데이터): 최대 65,535바이트

## TCP 시퀀스 번호, ACK 번호 (TCP Sequence Number, ACK Number)
예시: 500kb 메시지를 보낼 때, MSS=1000bytes
500kb = 500,000bytes = 500개의 세그먼트

시퀀스 번호: 각 세그먼트의 첫 번째 바이트의 **바이트 스트림 번호** - 0, 1000, 2000, 3000, 4000
ACK 번호: 수신자가 **다음에 받을 세그먼트**의 시퀀스 번호 - 1000, 2000, 3000, 4000, 5000
### 특징
- 패킷은 시퀀스 번호와 ACK 번호를 모두 가지고 있다
	- 데이터 패킷을 ACK 용으로 사용 가능
	- 전이중 통신 가능 (full-duplex)
- 실제로는 0부터 시작하지 않음
	- 초기 시퀀스 번호는 랜덤하게 선택됨. 왜일까? -> 새로운 패킷을 보낼 때마다 시퀀스 번호가 0부터 시작하면, 이전에 보낸 패킷과 중복될 수 있기 때문
- 시작 번호를 알 수 있는 방법
	- 3-way handshake: 초기 시퀀스 번호를 알려줌
- 수신자가 순서가 어긋난 패킷을 받았을 때
	- TCP에서 명시하지 않음

### 예시
- 사용자가 'C'를 입력한다.
- 호스트 A는 시퀀스 번호 42, 인정 번호 79, 데이터 'C'를 가진 패킷을 전송한다.
- 호스트 B는 'C'의 수신을 인정하고 'C'를 에코(반사)로 돌려보낸다.
- 호스트 B는 시퀀스 번호 79, 인정 번호 43, 데이터 'C'를 가진 패킷을 전송한다.
	- 시퀀스 번호 79: A가 보낸 ACK
	- 인정 번호 43: A가 보낸 Seq + 1
- 호스트 A는 'C'의 수신을 인정하고 시퀀스 번호 43, 인정 번호 80을 가진 패킷을 전송한다.
	- 시퀀스 번호 43: B가 보낸 ACK
	- 인정 번호 80: B가 보낸 Seq + 1

## TCP 왕복 시간, 타임아웃 (TCP Round-Trip Time, Timeout)
TCP 는 패킷 손실을 회복하기 위해 타임아웃 후 재전송한다.
- Timeout 값을 설정하는 법
	- RTT보다 길게 설정
		- RTT(Round-Trip Time): 패킷을 보내고 ACK를 받는 데 걸리는 시간
		- RTT는 변할 수 있다
	- 너무 짧으면: 성급한 타임아웃, 불필요한 재전송
	- 너무 길면: 세그먼트 손실에 대한 반응이 느림
	- 몇 개의 타이머가 필요한가
- RTT를 추정하는 방법
	- SampleRTT: 패킷(세그먼트)을 보내고 ACK를 받는 데 걸린 시간
		- 재전송은 무시. 왜? -> RTT가 길어지면 재전송이 빈번해질 수 있음
	- 변동성이 있으므로 여러 최근 측정치를 평균낸다.
- 지수 가중 이동 평균(Exponential Weighted Moving Average)
	> EstimatedRTT = (1-α) * EstimatedRTT + α * SampleRTT
	- 과거 샘플의 영향이 지수적으로 빠르게 감소함
		- $E'=(1-\alpha)\left\{(1-\alpha)E+\alpha S\right\} $
		- $E''=(1-\alpha)\left\{(1-\alpha)\left\{(1-\alpha)E+\alpha S\right\}+\alpha S\right\}$
		- ...
		- $E_n=(1-\alpha)E_{n-1}+\alpha S$
	- 일반적으로, α: 0.125
- 타임아웃 간격(TimeOut Interval): **추정된 RTT(EstimatedRTT)**에 "안전 마진"이 추가됨
	- 추정된 RTT의 변동이 크면 안전 마진도 커짐
	- DevRTT: RTT의 변동성
		> DevRTT = (1-β) * DevRTT + β * |SampleRTT - EstimatedRTT|
		- 일반적으로, β: 0.25
	- TCP의 타임아웃 간격(TimeoutInterval) = 추정된 RTT(EstimatedRTT) + 4 * DevRTT(safety margin)

# 3.5.2 TCP: 신뢰할 수 있는 데이터 전송(Reliable Data Transfer)
## 신뢰할 수 있는 데이터 전송(Reliable Data Transfer)
- **IP가 불안정하다**
	- 데이터가 손상, 분실, 순서변경, 삭제될 수 있다.
- TCP는 IP의 불안정성을 보완한다
	- 받은 바이트 스트림은 보낸 것과 정확히 일치함
	- 사용법
		- 파이프라인 세그먼트
		- 시퀀스 번호, ACK 번호
		- 타임아웃, 재전송
	- 재전송은 다음에 의해 트리거됨
		- 타임아웃
		- 중복된 ack
## TCP 송신자 이벤트(TCP Sender Events)
1. 애플리케이션으로부터 데이터를 받음
	- 시퀀스 번호를 할당하고, 데이터를 세그먼트로 나눔
	- 타이머가 시작됨
2. 타임아웃
	- 타이머가 만료되면, 세그먼트를 재전송
	- 타이머 재설정
3. ACK 수신
	- ACK가 이전에 인정받지 않은 세그먼트 인정
		- ACKed로 업데이트
	- ACK가 이전에 인정받은 세그먼트를 인정
		- 중복 ACK

## TCP: 재전송 시나리오(TCP: Retransmission Scenario)
### 시나리오1
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 전송한다.
- 타임아웃 후, 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 재전송한다.
- 호스트 B는 ACK 100을 보낸다.
- 문제: 잃어버린 ACK 시나리오

### 시나리오2
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 전송하고, 이어서 시퀀스 번호 100, 20 바이트의 데이터를 전송한다.
- 호스트 B는 ACK 100과 ACK 120을 전송한다.
- 호스트 A는 시퀀스 번호 92, 8 바이트의 데이터를 재전송한다.
- 호스트 B는 ACK 120을 다시 전송한다.
- 문제: 성급한 타임아웃 시나리오

### 시나리오3
- Host A는 시퀀스 번호 92로 8바이트의 데이터를 전송한다.
- 다음으로, 시퀀스 번호 100으로 20바이트의 데이터를 전송하지만, 이 데이터는 손실된다 (X로 표시).
- Host B는 시퀀스 번호 100의 데이터를 수신하지 못했기 때문에 ACK 100을 전송하여 이를 Host A에 알린다.
- 그 후, Host A는 시퀀스 번호 120으로 15바이트의 데이터를 전송하고, Host B는 ACK 120을 보낸다.
- 문제: 누적 ACK을 시나리오

## TCP ACK 생성(TCP ACK Generation)
- 수신자 이벤트: 순서대로 도착한 세그먼트가 예상 시퀀스 번호와 일치하며, 이전 모든 데이터는 이미 ACK이 완료된 상태다.
	- TCP 수신 액션: 지연된 ACK. 다음 세그먼트를 500ms 동안 기다린다. 다음 세그먼트가 없다면 ACK을 보낸다.
- 수신자 이벤트: 순서대로 도착한 세그먼트가 예상 시퀀스 번호와 일치하며, 다른 세그먼트에 대한 ACK이 대기 중이다.
	- TCP 수신 액션: 즉시 단일 누적 ACK을 보내어 순서대로 도착한 두 세그먼트를 모두 ACK한다.
- 수신자 이벤트: 예상보다 높은 시퀀스 번호를 가진 순서에 맞지 않는 세그먼트가 도착하며, 갭이 감지된다.
	- TCP 수신 액션: 즉시 중복 ACK을 보내어 다음 예상 바이트의 시퀀스 번호를 나타낸다.
- 수신자 이벤트: 갭을 부분적으로나 완전히 채우는 세그먼트가 도착한다.
	- TCP 수신 액션: 갭의 낮은 쪽에서 시작하는 세그먼트가 도착하면 즉시 ACK을 보낸다.

## TCP 빠른 재전송(TCP Fast Retransmit)
문제정의: 타임아웃 기간이 종종 상대적으로 김
아이디어: 중복 ACK을 통해 잃어버린 세그먼트를 식별하고, 즉시 재전송
	- 세그먼트가 손실되면, 중복 ACK이 많이 발생할 가능성이 있다.

TCP 빠른 재전송
	- 중복 ACK이 3개 이상 수신되면, 잃어버린 세그먼트로 간주하고 즉시 재전송
	- 가장 작은 시퀀스 번호를 가진 세그먼트를 재전송
	- 타임아웃을 기다리지 않음

예시)
- Host A는 시퀀스 번호 92에서 8바이트의 데이터를 전송하고, 이어서 시퀀스 번호 100에서 20바이트의 데이터를 전송한다.
- 시퀀스 번호 100의 데이터가 손실되었다는 표시(X)로 인해, Host B는 같은 시퀀스 번호에 대해 여러 번(3번) ACK 100을 반복해서 전송한다.
- Host A는 이 3중 중복 ACK을 받고, 손실된 시퀀스 번호 100의 데이터 20바이트를 즉시 재전송한다.
# 3.5.3 TCP: 흐름 제어 (TCP Flow Control)
# 3.5.4 TCP: 연결 관리 (TCP Connection Management)
## TCP 흐름 제어 (TCP Flow Control)
- 데이터를 교환하기 전에, 발신자와 수신자는 "핸드셰이크" 과정을 통해 아래 사항에 동의한다.
  - 연결을 설정하기로 동의한다(상대방이 연결 설정에 동의한다는 것을 알고 있다).
  - 연결 매개변수에 동의한다.

- 응용 프로그램
  - 연결 상태: ESTAB
  - 연결 변수:
    - seq # 클라이언트에서 서버로
    - 서버에서 클라이언트로
    - 서버, 클라이언트에서의 rcvBuffer 크기

- 네트워크
  - Socket clientSocket = newSocket("hostname","port number");
  - Socket connectionSocket = welcomeSocket.accept();

### 추가 설명

핸드셰이크 과정은 네트워크에서 서버와 클라이언트 간에 데이터 전송을 시작하기 전에 수행하는 초기 단계이다. 이 과정에서 두 시스템은 서로의 존재를 확인하고, 연결을 수립할 준비가 되었다는 것을 알린다. 핸드셰이크는 연결의 신뢰성을 보장하고, 데이터 전송 중에 발생할 수 있는 오류를 최소화하는 데 중요한 역할을 한다.

연결 변수들은 다음과 같다:
- seq # (Sequence Number): 데이터 패킷을 식별하고 순서대로 조립하기 위한 번호이다.
- rcvBuffer (Receive Buffer): 데이터를 수신하는 버퍼의 크기로, 서버와 클라이언트 각각에서 설정될 수 있다. 이 크기는 네트워크의 데이터 흐름을 조절하는 데 사용된다.

Socket 프로그래밍에서는 `newSocket` 함수를 사용하여 새로운 소켓을 생성하고, 호스트 이름과 포트 번호를 지정하여 네트워크 연결을 초기화한다. `welcomeSocket.accept()`는 서버 측에서 클라이언트의 연결 요청을 수락하며, 이로 인해 서버와 클라이언트 간의 연결이 성립된다.

## 연결을 설정하기로 합의 (Agreeing to Establish a Connection)
- 2단계 핸드셰이크:
	- "대화하자" → "확인"

- 질문: 2단계 핸드셰이크는 항상 네트워크에서 작동할까?
  - 가변 지연
  - 메시지 손실로 인한 재전송 메시지 (예: req_conn(x))
  - 메시지 재정렬
  - 상대방을 "볼" 수 없음
	
- 2단계 핸드셰이크 실패 시나리오:
	- 클라이언트는 연결을 종료하고, 서버는 x를 잊어버림
	- 결과는 클라이언트가 없는 반 열린 연결이 됨

### 추가 설명

2단계 핸드셰이크는 기본적으로 "대화하자"라고 요청하고, 상대방이 "확인"으로 응답하는 과정을 포함한다. 이는 서버와 클라이언트가 서로 연결을 시작하기로 합의했음을 의미한다.

그러나, 이런 방식의 핸드셰이크는 다음과 같은 이유로 항상 신뢰성 있는 연결을 보장하지 못할 수 있다:
- **가변 지연**: 네트워크의 상태나 트래픽 양에 따라 메시지가 도착하는 시간이 달라질 수 있다.
- **재전송 메시지**: 메시지가 중간에 손실되면, 손실된 메시지를 다시 전송해야 한다. 이 경우, 연결 요청 메시지(req_conn(x))와 같은 메시지가 여러 번 전송될 수 있다.
- **메시지 재정렬**: 네트워크에서 메시지가 전송된 순서대로 도착하지 않을 수 있다. 이는 메시지 처리에 혼란을 줄 수 있다.
- **상대방을 볼 수 없음**: 네트워크 통신은 물리적으로 서로를 볼 수 없기 때문에, 상대방의 현재 상태나 준비 상태를 정확히 알 수 없다.

이러한 요소들은 2단계 핸드셰이크의 신뢰성을 저하시킬 수 있으며, 따라서 보다 견고한 3단계 핸드셰이크 방식을 사용하는 경우가 많다.
*실패 시나리오*
1. **첫 번째 시나리오**:
	- 클라이언트가 x를 선택하고 `req_conn(x)`를 전송한다.
	- 클라이언트는 응답이 지연되거나 손실된다고 판단하여 `req_conn(x)`를 재전송한다.
	- 서버는 `acc_conn(x)`로 응답하지만, 클라이언트는 연결을 종료한다.
	- 서버는 연결이 완료되었다고 판단하지만, 실제로는 클라이언트가 존재하지 않는 상태(반 열린 연결)가 된다.

2. **두 번째 시나리오**:
	- 클라이언트가 x를 선택하고 `req_conn(x)`를 전송한다.
	- 클라이언트는 응답이 지연되거나 손실된다고 판단하여 데이터 `data(x+1)`를 재전송한다.
	- 서버는 `acc_conn(x)`로 응답하고, 클라이언트는 데이터 `data(x+1)`를 수신하여 연결이 완료된다고 판단한다.
	- 그러나 서버는 연결 요청 `req_conn(x)`에 대한 기록을 잊어버려, 데이터를 수신한 후에도 클라이언트의 초기 연결 요청을 기다리는 상태가 된다.

이 시나리오들은 네트워크의 지연, 메시지 손실, 메시지 순서의 혼란 등 다양한 이유로 인해 발생할 수 있다. 이를 해결하기 위해 통상적으로는 더 안정적인 3단계 핸드셰이크를 사용하는 것이 권장된다.

## TCP *3단계 핸드셰이크* (TCP 3-Way Handshake)
- 클라이언트 상태
	- 초기 상태: CLOSED
	- 초기 시퀀스 번호 x 선택 후 TCP SYN 메시지 전송
	- 상태 변화: SYN SENT → ESTAB
	- SYNACK(x) 수신: 서버가 동작 중임을 표시, SYNACK에 대한 ACK 전송, 이 세그먼트는 클라이언트에서 서버로의 데이터를 포함할 수 있음

- 서버 상태
	- 초기 상태: LISTEN
	- 초기 시퀀스 번호 y 선택 후 TCP *SYNACK* 메시지 전송(SYN=1, ACK=1), SYN을 확인함
	- 상태 변화: SYN RCVD → ESTAB
	- ACK(y) 수신: 클라이언트가 동작 중임을 표시

### 추가 설명

TCP 3단계 핸드셰이크는 네트워크에서 연결의 신뢰성을 보장하기 위해 사용되는 방법이다. 이 과정은 다음과 같이 세 단계로 이루어진다:

1. **SYN 전송**: 클라이언트는 서버에게 연결을 요청하는 SYN 패킷을 보낸다. 이 패킷은 연결 요청과 함께 클라이언트의 초기 시퀀스 번호(x)가 포함되어 있다.
2. **SYNACK 응답**: 서버는 클라이언트의 SYN을 받고, SYN과 ACK을 모두 설정한 SYNACK 패킷을 클라이언트에게 보낸다. 이 패킷은 서버의 초기 시퀀스 번호(y)와 클라이언트의 시퀀스 번호에 1을 더한 값(x+1)을 ACK 번호로 사용한다.
3. **ACK 확인**: 클라이언트는 서버의 SYNACK 패킷을 받고, 이를 확인하는 ACK 패킷을 서버에 보낸다. 이 패킷은 서버의 시퀀스 번호에 1을 더한 값(y+1)을 ACK 번호로 포함한다.

이 과정을 통해 두 시스템은 서로의 존재와 준비 상태를 확인하고, 안정적으로 데이터를 교환할 수 있는 연결을 성립한다. 이는 데이터의 손실이나 순서 문제 등을 효과적으로 방지하여 통신의 신뢰성을 높인다.


## TCP 3단계 핸드셰이크: FSM-유한 상태 기계 (TCP 3-Way Handshake: FSM)
- 서버
	- 초기 상태: CLOSED
	- `welcomeSocket.accept();` 실행 후 상태 변화: LISTEN
	- SYN(x) 수신, SYNACK(seq=y, ACKnum=x+1) 전송, 클라이언트로의 응답을 위한 새 소켓 생성
	- 상태 변화: SYN RCVD
	- ACK(ACKnum=y+1) 수신 후 상태
- 클라이언트
	- 초기 상태: CLOSED 
	- `newSocket("hostname", "port number");` 실행 후 SYN(seq=x) 전송
	- 상태 변화: SYN SENT
	- SYNACK(seq=y, ACKnum=x+1) 수신, ACK(ACKnum=y+1) 전송
	- 상태 변화: ESTAB

### 추가 설명

TCP 3단계 핸드셰이크 과정은 유한 상태 기계(FSM)를 사용하여 모델링할 수 있다. 이 기계는 각 상태(예: CLOSED, LISTEN, SYN SENT, SYN RCVD, ESTAB)와 이 상태들 사이의 전이를 명확하게 표현한다. 각 전이는 네트워크 패킷의 수신이나 송신에 의해 트리거된다.

- **서버**는 CLOSED 상태에서 시작하여 `welcomeSocket.accept();`를 호출함으로써 LISTEN 상태로 이동한다. 이후 클라이언트로부터 SYN 패킷을 수신하면 SYN RCVD 상태로 전환되고, 클라이언트에게 SYNACK 패킷을 보낸다. 서버가 클라이언트로부터 ACK를 수신하면 최종적으로 ESTAB 상태가 되어 연결이 확립된다.

- **클라이언트**는 CLOSED 상태에서 시작하여 서버에 연결하기 위해 `newSocket("hostname", "port number");`를 호출하고 SYN 패킷을 전송하여 SYN SENT 상태로 전환한다. 서버로부터 SYNACK를 수신하면, 필요한 ACK를 전송하고 ESTAB 상태로 전환하여 연결이 확립된다.

이 모델은 TCP 연결이 어떻게 단계적으로 설정되는지를 명확하게 보여주며, 각 단계에서 어떤 프로토콜 메시지가 교환되는지를 설명한다. 이런 방식으로 TCP는 네트워크 상에서 데이터를 안정적으로 전송할 수 있는 견고한 연결을 제공한다.

## TCP: 연결 종료
- 클라이언트와 서버는 각자의 연결을 종료한다.
	- FIN 비트가 1인 TCP 세그먼트를 전송한다.
	- 수신한 FIN에 대해 ACK로 응답한다.
	- FIN을 받은 후, ACK는 자신의 FIN과 함께 결합될 수 있다.
	- 동시에 이루어지는 FIN 교환을 처리할 수 있다.

![240507-174238w](/posts/240507-174238.png)

- 클라이언트 상태
	- ESTAB에서 시작
	- `clientSocket.close()` 실행: 더 이상 데이터를 전송할 수 없지만 데이터 수신은 가능
	- FIN_WAIT_1: 서버의 종료를 기다림 - 서버가 Acknum=x+1을 보내면 FIN_WAIT_2로 전환
	- FIN_WAIT_2: 서버의 종료를 기다림 - 서버가 FIN을 보내면 TIMED_WAIT로 전환
	- TIMED_WAIT: 최대 세그먼트 수명의 2배 시간 동안 대기 - 서버에게 ACKnum=y+1을 보낸 후 세그먼트 생명주기의 2배 이후 CLOSED로 전환
	- CLOSED: 연결 종료

- 서버 상태
	- ESTAB에서 시작
	- `clientSocket.close()` 수신 -> CLOSE_WAIT: 여전히 데이터를 전송할 수 있음
	- LAST_ACK: 더 이상 데이터를 전송할 수 없음 - 클라이언트에게 Seq=y 전송
	- 클라이언트에게 ACKnum 수신 -> 즉시 CLOSED: 연결 종료
	
### 추가 설명
TCP 연결을 종료하는 과정은 연결을 설정하는 과정만큼 중요하다. 이 과정은 데이터 전송이 완료된 후에 안정적으로 연결을 마무리 지어 자원을 해제하는 데 필요하다.

1. **FIN 비트 전송**: 연결을 종료하려는 각 단말은 FIN 비트가 설정된 TCP 세그먼트를 상대방에게 전송한다. 이는 연결의 한 방향을 종료하겠다는 의도를 나타낸다.
2. **ACK 응답**: 수신 단말은 FIN 세그먼트를 받고, 이에 대해 ACK를 전송하여 수신을 확인한다. 또한, 수신 단말이 아직 보내지 않은 데이터가 있을 경우, 자신의 FIN 세그먼트와 함께 ACK를 전송할 수 있다.
3. **동시 종료 처리**: 두 단말이 거의 동시에 FIN 세그먼트를 보낼 경우, 각 단말은 상대방의 FIN에 대해 ACK를 보내며 이를 처리한다.

이 과정은 네트워크 상의 데이터 손실 없이 깔끔하게 연결을 종료하기 위해 설계되었다. 동시에 이루어지는 FIN 교환은 TCP 프로토콜이 복잡한 네트워크 상황에서도 연결을 효과적으로 종료할 수 있도록 보장한다. 이러한 메커니즘은 네트워크 자원의 효율적인 관리와 안정적인 네트워크 운영을 지원한다.
	

TCP 연결 종료 과정은 클라이언트와 서버 각각의 상태 변화를 통해 관리된다. 이 과정은 다음과 같은 단계를 포함한다:

1. **FIN_WAIT_1**: 클라이언트가 연결을 종료하고자 할 때 `FIN` 패킷을 전송하고, FIN_WAIT_1 상태로 전환한다.
2. **CLOSE_WAIT**: 서버가 클라이언트로부터 `FIN` 패킷을 받고, 이에 대한 `ACK`를 보낸 후 CLOSE_WAIT 상태로 전환한다. 이 상태에서 서버는 클라이언트에게 마지막 데이터를 전송할 수 있다.
3. **LAST_ACK**: 서버가 모든 데이터 전송을 완료하고 자신의 `FIN` 패킷을 클라이언트에게 보내면, LAST_ACK 상태로 전환한다.
4. **FIN_WAIT_2**: 클라이언트는 서버의 `FIN` 패킷을 기다리는 동안 FIN_WAIT_2 상태에 있다.
5. **TIMED_WAIT**: 클라이언트는 서버로부터 `FIN`을 받고, 이에 대한 `ACK`를 보낸 후 TIMED_WAIT 상태로 전환된다. 이 상태에서 일정 시간(보통 최대 세그먼트 수명의 2배)을 대기하여, 네트워크 지연으로 인한 패킷 손실이 없는지 확인한다.
6. **CLOSED**: 양쪽 모두 `CLOSED` 상태로 전환되며, 연결이 완전히 종료된다.

이 단계들은 TCP 연결이 완전히 정리되고 모든 자원이 해제될 때까지 관리되어 네트워크 상의 자원 사용을 최적화하며 데이터 손실을 방지한다.
