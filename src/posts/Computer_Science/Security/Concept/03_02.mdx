## RSA 암호화 개요 (Overview of RSA Encryption)
N은 두 소수 p, q의 곱이다. 즉, $N = p * q$이다.
그 후, 주요 문제는 p와 q를 찾는 것이다.
- 1978년에 Rivest, Shamir, Adleman에 의해 설계되었다.
- 가장 인기 있고 널리 사용되는 공개 키 암호화 체계다.
- 인수 분해의 어려움에 기반하고 있다.
- 암호화 및 복호화 알고리즘은 모듈러 지수화로 이루어져 있다.
- 결정론적 암호화는 IND-XXX 보안을 달성할 수 없다.
- 실제로는 RSA 암호화의 변형(예: RSA-OAEP)을 사용한다.
- 양자 공격에 대해서는 안전하지 않다.

## RSA: 키 생성 (RSA: Key Generation)
1. 두 개의 소수를 선택합니다. 이 두 소수를 p와 q라고 한다.
2. $N = p * q$를 계산합니다.
3. $\phi(N) = (p-1) * (q-1)$를 계산합니다. $\phi(N)$은 N과 서로소인 수의 개수를 의미함
	[오일러 파이 함수](/blog/Computer_Science/Security/Concept/03_01)
4. $e$를 선택합니다. $1 < e < \phi(N)$이며, $e$와 $\phi(N)$은 서로소여야 함.
5. $d$를 계산합니다. $d$는 $d * e \equiv 1 \pmod{\phi(N)}$을 만족하는 수이다.
	확장된 유클리드 알고리즘을 사용하여 계산
6. 공개키 $pk=(N, e)$이며, 개인키 $sk=d$이다.

#### 정리 (RSA 키 생성)
- RSA 키 생성은 두 소수 $p$와 $q$를 선택하고, 이를 이용하여 공개 키 $(N, e)$와 개인 키 $d$를 생성하는 과정이다.
- $N$은 두 소수의 곱으로, RSA 암호화에서 중요한 모듈로 사용된다.
- $\phi(N)$은 오일러의 피 함수로, $N$과 서로소인 정수의 개수를 나타낸다.
- 공개 지수 $e$는 암호화에 사용되며, 개인 키 $d$와 함께 중요한 역할을 한다.
- $d \cdot e \equiv 1 \ (\text{mod} \ \phi(N))$는 개인 키와 공개 지수가 서로 *역원 관계*임을 보장하는 식이다.
	- 이 식은 확장된 유클리드 알고리즘을 사용하여 계산된다.

## RSA: 암호화 & 복호화 (RSA: Encryption & Decryption)
### 암호화
공개 키 $pk = (N, e)$와 평문 $M \in \mathbb{Z}_N$이 주어졌을 때, 
$C := RSA.Enc(pk, M) = M^e \ (\text{mod} \ N)$ 를 계산하고 $C$를 출력한다.
### 복호화
개인 키 $sk = d$와 암호문 $C \in \mathbb{Z}_N$이 주어졌을 때, 
$M' := RSA.Dec(sk, C) = C^d \ (\text{mod} \ N)$ 를 계산하고 $M'$를 출력한다.

#### 정리 (RSA 암호화 & 복호화)
- RSA 암호화는 공개 키 $e$와 모듈로 $N$을 사용하여 평문 $M$을 암호문 $C$로 변환하는 과정이다.
- RSA 복호화는 개인 키 $d$를 사용하여 암호문 $C$를 다시 평문 $M'$로 변환하는 과정이다.
- 암호화와 복호화 모두 모듈로 $N$을 기반으로 한 거듭제곱 연산을 필요로 하며, 이는 컴퓨터가 큰 수의 연산을 효율적으로 수행할 수 있게 해주는 중요한 알고리즘에 기초한다.

## RSA의 정확성	(Correctness of RSA)
공개 키 암호화 PKE는 다음이 성립할 때 정확하다고 한다. 보안 파라미터 λ와 모든 평문 M에 대해,
$$ Dec(sk, Enc(pk, M)) = M $$
여기서 (pk, sk)는 KeyGen(λ)의 출력이다.

RSA의 정확성:
$$ M' = RSA.Dec(sk, RSA.Enc(pk, M)) $$
$$ = C^d = (M^e)^d = M^{ed} = M^{s\phi(N) + 1} \mod N $$
$$ = (M^{\phi(N)})^s \cdot M = M (\because \text{오일러 정리})$$

#### 추가 설명

- **공개 키 암호화의 정확성**: 공개 키 암호화 체계는 암호화와 복호화 과정을 거친 후 원래의 메시지 M을 정확히 복원할 수 있어야 한다. 이는 시스템이 실용적으로 사용될 수 있는 기본적인 조건이다.
- **RSA 알고리즘의 작동 원리**: RSA 암호화 과정에서는 메시지 M을 공개키 e를 이용하여 $M^e \mod N$로 암호화하고, 개인키 d를 사용하여 복호화 과정에서 $(M^e)^d \mod N$ 연산을 수행한다. 이론적으로 $ed \mod \phi(N)$은 1이 되어야 하며, 이는 오일러의 정리에 기반한다.
- **오일러의 정리**: $\phi(N)$은 N의 오일러 피-함수로, N보다 작은 양의 정수 중 N과 서로소인 수의 개수를 나타낸다. 오일러의 정리에 따르면, 어떤 정수 a와 N이 서로소일 때, $a^{\phi(N)} \equiv 1 \mod N$이 성립한다. RSA에서는 이 성질을 이용하여 암호화와 복호화 과정에서 발생하는 지수 연산을 간소화한다.

RSA 암호체계는 이러한 수학적 원리를 바탕으로 안전하게 정보를 암호화하고 복호화하는 데 사용된다. 이 암호체계의 정확성과 안정성은 다양한 디지털 통신 및 데이터 보안 분야에서 중요한 역할을 한다.


## RSA: 예시 (RSA: Example)
**키 생성**

1. $p = 13, q = 17$
2. $N = 13 \times 17 = 221$
3. $\phi(N) = (13 - 1)(17 - 1) = 12 \times 16 = 192$
4. $e = 5$
5. $d = 77$ (즉, $5 \times 77 = 385 = 1 \mod 192$)

**암호화**

- $M = 3$
- $C = M^e = 3^5 = 243 = 22 \mod 221$

**복호화**

- $C = 22$
- $M' = C^d = 22^{77} = (22^7)^{11} = 61^{11} = 3 \mod 221$

#### 추가 설명

- **키 생성 과정**: RSA 알고리즘의 키 생성은 두 소수 $p$와 $q$를 선택하고, 이 둘을 곱하여 $N$을 생성한다. $\phi(N)$은 $N$의 오일러 피-함수 값으로, $(p-1)(q-1)$을 계산하여 얻는다. 공개키 $e$는 $\phi(N)$과 서로소인 수 중에서 선택되며, 개인키 $d$는 $ed \equiv 1 \mod \phi(N)$을 만족하는 값이다.
- **암호화**: 메시지 $M$을 공개키 $e$를 사용하여 $M^e \mod N$으로 암호화한다. 여기서는 $M = 3$이며, $3^5 = 243$의 계산 결과를 221로 나눈 나머지가 $C$가 된다.
- **복호화**: 암호문 $C$를 개인키 $d$를 사용하여 $C^d \mod N$으로 복호화한다. $C = 22$이며, 이를 $77$승하여 나머지 연산을 수행하면 원래의 메시지 $M$이 복원된다.

이 예제에서 볼 수 있듯이, RSA 알고리즘은 모듈러 산술과 지수적 연산을 기반으로 안전한 키 교환과 암호화, 복호화를 가능하게 한다. 이 과정에서 $N$, $\phi(N)$, $e$, 그리고 $d$의 선택이 중요하며, 이 값들의 정확한 계산이 RSA의 보안성과 성능을 결정짓는다.

## RSA: 빠른 암호화 (RSA: Fast Encryption)
**암호화**

<Bbox>$C := RSA.Enc(pk, M) = M^e \mod N$</Bbox>
- 일반적으로 공개 키 지수 $e$는 대략 $\log_2 N$-비트이다. 따라서 평균적으로 $1.5(\log_2 N)$번의 곱셈이 필요하다.
- 매우 작고 햄밍 가중치가 낮은 $e$를 선택한다. 예를 들어, $e = 3, 17, 2^{16} + 1$

| $e$ | $e$의 이진 문자열 | 곱셈 횟수 |
| --- | --- | --- |
| 3 | 11₂ | 2 |
| 17 | 10001₂ | 5 |
| \(2^{16} + 1\) | 10000 0000 0001₂ | 17 |
- 개인 키 $d$는 거의 전체 비트 길이를 가지지만 $e$는 매우 작다.

**복호화의 빠른 속도를 위한 방법**

- 개인 키 지수 $d$는 Coppersmith 공격에 의해 $N^{0.292}$보다 커야 한다. 따라서 매우 작은 $d$를 사용할 수 없다.
- 중국인의 나머지 정리(Chinese Remainder Theorem, CRT) 사용:
    1. 계산:
        - $d_p = d \mod (p - 1)$
        - $d_q = d \mod (q - 1)$
    2. 계산:
        - $C_{dp} = C^{d_p} \mod p$
        - $C_{dq} = C^{d_q} \mod q$
    3. 계산:
        - $M = C_{dp} \cdot q \cdot M_q + C_{dq} \cdot p \cdot M_p$
        이 과정은 중국인의 나머지 정리를 사용하여 최종 메시지 $M$을 계산한다.

#### 추가 설명

- **공개 키 지수 $e$의 선택**: RSA 암호화의 속도를 높이기 위해서는 공개 키 지수 $e$를 가능한 작게 선택하는 것이 좋다. 햄밍 가중치가 낮은 $e$는 해당 이진수에서 1의 개수가 적은 것을 의미하며, 곱셈 연산의 횟수를 줄일 수 있다. 예를 들어, $e = 3$의 경우 이진수로는 '11'이고, 1이 두 개밖에 없기 때문에 곱셈이 2회만 필요하다.
- **암호화 과정의 계산 복잡도**: RSA에서 $M^e \mod N$을 계산할 때, $e$의 이진수 표현에서 1이 있는 위치에 따라 순차적으로 곱셈을 수행한다. 따라서 $e$의 선택은 암호화 과정의 효율성을 크게 좌우한다.
- **복잡한 계산의 최소화**: 예를 들어, $e = 2^{16} + 1$은 이진수에서 두 개의 1을 포함하고 있으며, 이는 17번의 곱셈이 필요하다고 계산된다. 이러한 큰 수의 곱셈은 비용이 많이 들기 때문에, 작은 $e$를 선택하는 것이 일반적으로 더 효율적이다.

이러한 최적화는 특히 큰 데이터를 다루거나 높은 처리량이 요구되는 애플리케이션에서 RSA 암호화의 성능을 크게 개선할 수 있다.

- **개인 키 지수 $d$의 크기**: $d$가 너무 작으면 Coppersmith 공격 같은 특정 암호 분석 기법에 취약할 수 있다. 따라서 $d$는 일정 크기 이상으로 설정되어야 한다.
- **중국인의 나머지 정리의 활용**: RSA에서 중국인의 나머지 정리를 사용하는 것은 복호화 과정을 더 빠르게 처리하기 위함이다. $p$와 $q$는 소수이며 $N$의 인수이다. 각각 $p$와 $q$에 대해 별도로 복호화 연산을 수행한 후, 이 결과를 합쳐서 원래의 메시지 $M$을 복구한다. 이 방법은 전체 $N$에 대해 연산을 수행하는 것보다 훨씬 빠르다.
- **$C_{dp}$와 $C_{dq}$ 계산의 중요성**: 이 단계에서는 각각 $p$와 $q$ 모듈로 $C$의 $d_p$승과 $d_q$승을 계산한다. 이는 $p$와 $q$ 각각에 대해 복호화를 수행하는 것과 같으며, 각 결과는 중국인의 나머지 정리를 통해 결합된다.

이러한 최적화 기법은 특히 대규모 RSA 시스템에서 복호화 시간을 상당히 단축시키는 데 도움이 된다.

## CRT를 이용한 RSA 복호화 (RSA Decryption using CRT)

- 이전 예제에서의 복호화
    - $N = 221$, $p = 13$, $q = 17$, $d = 77$, $C = 22$
    - 따라서 $M' = C^d = 22^{77} = (22^{11})^{7} \times 22^2 = 61^{11} \times 3 = 3$ (mod 221)
- $d_p = d \mod (p-1)$
    - $d_p = 77 \mod 12 = 5$
- $d_q = d \mod (q-1)$
    - $d_q = 77 \mod 16 = 13$
- $C_{dp} = C^{d_p} \mod p$
    - $C_{dp} = 22^5 \mod 13 = 3$
- $C_{dq} = C^{d_q} \mod q$
    - $C_{dq} = 22^{13} \mod 17 = 3$
- 중국인의 나머지 정리를 사용하여
    - $M = C_{dp} \cdot M_q + C_{dq} \cdot p \cdot M_p$
    - $M = 3 \cdot 14 + 3 \cdot 13 \cdot 10 = 666$
    - $M = 666 \mod 221 = 3$
- 따라서 $M_p = 17^{-1} \mod 13 = 4$ (mod 13), $M_q = 13^{-1} \mod 17 = 4$ (mod 17)

### 추가 설명

이 슬라이드는 RSA 알고리즘의 복호화 과정을 중국인의 나머지 정리(CRT)를 사용하여 효율적으로 계산하는 방법을 설명한다.

- **RSA 알고리즘**은 공개 키 암호화 방식 중 하나로, 두 개의 큰 소수 $p$와 $q$를 사용하여 만든 $N = p \cdot q$와 이를 이용한 복호화 키 $d$로 구성된다.
- 복호화 과정에서 $C^d \mod N$을 직접 계산하는 대신, CRT를 활용하면 $p$와 $q$에서 각각 계산한 결과를 합쳐 최종 결과를 얻을 수 있다. 이는 큰 숫자의 연산을 간소화하여 계산 속도를 향상시킨다.
- **CRT의 사용**은 $C^{d_p} \mod p$와 $C^{d_q} \mod q$의 결과를 각각 더 작은 모듈로 계산하고, 이를 적절히 조합하여 $N$에 대한 나머지를 구한다. 이 예에서는 최종적으로 $M = 3$을 얻는다.

이 방법은 RSA 알고리즘의 복호화를 보다 실용적으로 적용할 수 있게 하여, 보안이 중요한 다양한 전자 통신 및 데이터 저장에서 널리 사용된다.


## 최적 비대칭 암호화 패딩 (Optimal Asymmetric Encryption Padding, OAEP)
> RSA-OAEP는 RSA 암호화에 사용되는 패딩 방법 중 하나이다. 
RSA-OAEP는 RSA 암호화의 보안성을 높이기 위해 개발된 방법으로, 무작위성과 해시 함수를 사용하여 패딩을 적용한다.

![240514-100602](/posts/240514-100602.png)
1. $k - |M| -2|H| - 2$의 길이를 가진 문자열 PS(Padding String) 생성
2. 연결 - DB(Data Block) = $\text{Hash}(L) || PS || 0x01 || M$
3. $|H|$의 길이를 가진 무작위 바이트 문자열 Seed 생성
4. dbMask = $\text{MGF}(Seed, k - |H| - 1)$
5. MaskedDB = DB $\oplus$ dbMask
6. SeedMask = $\text{MGF}(dbMask, |H|)$
7. MaskedSeed = Seed $\oplus$ SeedMask
8. EM(Encoded Message) = $0x00 || MaskedSeed || MaskedDB$

