## RSA: 키 생성 (RSA: Key Generation)
1. 두 개의 큰 소수 p, q를 선택한다.
2. $N = p * q$를 계산한다.
3. $\phi(N) = (p - 1)(q - 1)$를 계산한다.
4. $e$를 선택한다. (단, $1 < e < \phi(N)$이고, $gcd(e, \phi(N)) = 1$이어야 한다.)
5. $d * e= 1 \pmod{\phi(N)}$를 만족하는 비밀 키 $d$를 계산한다.
6. 공개 키 $pk$는 $(N, e)$이고, 비밀 키 $sk$는 $(N, d)$이다.

## RSA: 암호화 & 복호화 (RSA: Encryption & Decryption)
- 암호화
	- 공개 키 $pk = (N, e)$와 평문 $M$을 입력으로 받는다.
	- $C := RSA.Enc(pk, M) = M^e \pmod{N}$을 계산한다.
	- $C$를 반환한다.
- 복호화
	- 비밀 키 $sk = (N, d)$와 암호문 $C$를 입력으로 받는다.
	- $M' := RSA.Dec(sk, C) = C^d \pmod{N}$을 계산한다.
	- $M'$을 반환한다.

## 모듈러 지수승 (Modular Exponentiation)
$g^a \pmod{p}$를 계산하는 방법
Naive 한 방법 : (a-1)번의 곱셈이 필요하다.
### 왼쪽에서 오른쪽 모듈러 지수승(L2RME)
입력: $g, a = (a_{l-1}, a_{l-2}, ... , a_1, a_0)_2, p$

출력: $g^a \pmod{p}$

```python title="왼쪽에서 오른쪽 모듈러 지수승"
R = 1
for i from l - 1 down to 0 do
		R = R^2 (mod p)
		if a_i = 1 then
				R = R * g (mod p)
		end if
end for
return R
```
#### 예시
$4^{25} \pmod{31}$을 계산하시오.
- $25 = (11001)_2$ -> a를 2진수로 변환, $l = 5$
- $a_4 = 1, a_3 = 1, a_2 = 0, a_1 = 0, a_0 = 1$
- $a_4 = 1$이므로 $R = 1^2 * 4 \pmod{31} = 4$
- $a_3 = 1$이므로 $R = 4^2*4 \pmod{31} = 2$
- $a_2 = 0$이므로 $R = 2^2 \pmod{31} = 4$
- $a_1 = 0$이므로 $R = 4^2 \pmod{31} = 16$
- $a_0 = 1$이므로 $R = 16^2*4 \pmod{31} = 29$
- 따라서, $4^{25} \pmod{31} = 29$

$log_2a + HW(a) - 1$번의 곱셈이 필요하다.

$HW(a)$는 a의 비트 중 1의 개수이다.

### 오른쪽에서 왼쪽 모듈러 지수승(R2LME)
입력: $g, a = (a_{l-1}, a_{l-2}, ... , a_1, a_0)_2, p$
출력: $g^a \pmod{p}$

```python title="오른쪽에서 왼쪽 모듈러 지수승"
R = 1, T = g
for i from 0 to l - 2 do
		if a_i = 1 then
				R = R * T (mod p)
		end if
		T = T^2 (mod p)
end for
R = R * T (mod p)
return R
```
#### 예시
$4^{25} \pmod{31}$을 계산하시오.
- $25 = (11001)_2$ -> a를 2진수로 변환, $l = 5$
- $a_0 = 1$이므로 $R = 1 * 4 \pmod{31} = 4, T = 4$
- $a_1 = 0$이므로 $R = 4, T = 4^2 \pmod{31} = 16$
- $a_2 = 0$이므로 $R = 4, T = 16^2 \pmod{31} = 25$
- $a_3 = 1$이므로 $R = 4 * 25 \pmod{31} = 29, T = 25^2 \pmod{31} = 4$
- $a_4 = 1$이므로 $R = 29 * 4 \pmod{31} = 29$
- 따라서, $4^{25} \pmod{31} = 29$

$log_2a + HW(a) - 1$번의 곱셈이 필요하다.

$HW(a)$는 a의 비트 중 1의 개수이다.

## 정수 위의 유클리드 알고리즘 (Euclidean Algorithm on Integers)
> a와 b가 양의 정수이고 a > b일 때, $\gcd(a, b) = \gcd(b, a \pmod{b})$이다.

### 정수 위의 유클리드 알고리즘(Euclidean Algorithm on Integers)
입력: 두 양의 정수 a, b (a >= b)
출력: a와 b의 최대공약수

```pseudo title="정수 위의 유클리드 알고리즘"
r = a, r' = b
while r' != 0 do
		r'' = r mod r'
		r = r'
		r' = r''
end while
d = r
return d
```
#### 예시
$\gcd(48, 18)$을 계산하시오.
- $48 = 18 * 2 + 12$
- $18 = 12 * 1 + 6$
- $12 = 6 * 2 + 0$
- 따라서, $\gcd(48, 18) = 6$

## 확장된 유클리드 알고리즘 (Extended Euclidean Algorithm)
> $a, b, r$이 양의 정수이고 $d = \gcd(a, b)$일 때, $ax + by = d$이 성립하며 
$x, y \in \mathbb{Z}$는 $d|r$일 때 존재한다.($d|r$은 $d$가 $r$을 나눈다는 의미이다.)

입력: 두 양의 정수 $a, b (a >= b)$
출력: $a$와 $b$의 최대공약수 d와 $d = ax + by$를 만족하는 $x, y$

```pseudo title="확장된 유클리드 알고리즘"
r = a, r' = b, x = 1, y = 0, x' = 0, y' = 1
while r' != 0 do
		q = r // r'
		r'' = r mod r'
		(r, x, y, r', x', y') = (r', x', y', r'', x - q * x', y - q * y')
end while
d = r
return d, x, y
```

예시: $\gcd(48, 18)$을 계산하시오.
- $r = 48, r' = 18, x = 1, y = 0, x' = 0, y' = 1$
- $q = 48 // 18 = 2, r'' = 48 mod 18 = 12$, $(r, x, y, r', x', y')\\
	= (18, 0, 1, 12, 1 - 2 * 0, 0 - 2 * 1) = (18, 0, 1, 12, 1, -2)$
- $q = 18 // 12 = 1, r'' = 18 mod 12 = 6$, $(r, x, y, r', x', y')\\
	= (12, 1, -2, 6, 0 - 1 * 1, 1 - 1 * -2) = (12, 1, -2, 6, -1, 3)$
- $q = 12 // 6 = 2, r'' = 12 mod 6 = 0$, $(r, x, y, r', x', y')\\
	= (6, -1, 3, 0, 1 - 2 * -1, -2 - 2 * 3) = (6, -1, 3, 0, 3, -8)$
- 따라서, $\gcd(48, 18) = 6$이고, $6 = -1 * 48 + 3 * 18$이다.

## 오일러 파이 함수 (Euler's Phi Function)
> 오일러 파이 함수 $\phi(n)$은 $\mathbb{Z}_m$에서 m과 서로소인 수의 개수를 의미한다.

$m = p_1^{e_1} * p_2^{e_2} * ... * p_n^{e_n}$ 일 때(이때, $p_i$는 서로 다른 소수, $e_i$는 양의 정수), $\phi(n)$은 다음과 같이 계산할 수 있다.
<Bbox>

$\phi(n) = \prod _{i=1}^{n}(p_i^{e_i} - p_i^{e_i-1})$
</Bbox>

$\phi(p) = p - 1$ (p는 소수)

### 예시
1. $\phi(6) = 2$ (6과 서로소인 수는 1, 5), $\phi(8) = 4$ (8과 서로소인 수는 1, 3, 5, 7)
2. $m = 240$ 이라 하면, $240 = 2^4 * 3^1 * 5^1$이므로

$\phi(240) = (2^4 - 2^3) * (3^1 - 3^0) * (5^1 - 5^0) = 64$

## 오일러 정리 (Euler's Theorem)
<Bbox>
서로 소로수인 정수 $a$, 정수 $m$에 대하여, $a^{\phi(m)} \equiv 1 \pmod{m}$이다.
</Bbox>

### 예시
$a = 5, m = 12$ 일 때, $\phi(12) = \phi(2^2 * 3^1) = (2^2 - 2^1) * (3^1 - 3^0) = 4$이다.
$\because (1, 5, 7, 11)$
따라서, $5^4 \equiv 1 \pmod{12}$이다.

## 페르마의 소정리 (Fermat's Little Theorem)
<Bbox>

정수$a$, 소수 $p$ 에 대하여, $a^{p} \equiv a \pmod{p}$이다.
</Bbox>


#### 예시
1. $p = 7, a = 2$일 때, $2^7 \equiv 2 \pmod{7}$이다.
2. $p = 11, a = 3$일 때, $3^{11} \equiv 3 \pmod{11}$이다.

### 따름정리
<Bbox>
정수 $a$, 소수 $p$에 대하여, $a^{p-1} \equiv 1 \pmod{p}$이다.<br/>또한, $a^{-1} = a^{p-2} \pmod{p}$이다.
</Bbox>

#### 증명
$a\times a \times a \times ... \times a \equiv a  \pmod{p}$이므로, <MathBox>$a^{p-1} \equiv 1 \pmod{p}$</MathBox>이다.
$a \times a^{-1} \equiv 1 \pmod{p}$이므로, <MathBox>$a^{-1} = a^{p-2} \pmod{p}$</MathBox>이다.


## 중국인의 나머지 정리 (Chinese Remainder Theorem)
<Bbox>

$p$와 $q$가 서로소일 때, 두 방정식<br/>$x ≡ a \pmod{p}$<br/>$x ≡ b \pmod{p}$<br/>은 $pq$에 대한 $X$의 유일한 해를 가진다.
</Bbox>

#### 증명
1. 존재성:

	$x = a \times q \times M_q + b \times p \times M_p \pmod{pq}$

	여기서 $M_q$는 $q^{-1} \pmod{p}$이고, $M_p$는 $p^{-1} \pmod{q}$이다.

2. 유일성:

	만약 $x ≡ y \pmod{p}$이고 $x ≡ y \pmod{q}$라면, $x - y$는 $p$와 $q$의 배수이다. 
	
	따라서, $x - y$는 $pq$의 배수이며 $x ≡ y \pmod{pq}$이다.

#### 추가 설명

중국인의 나머지 정리는 두 개 이상의 서로소인 모듈러 산술 시스템에서 유일한 해를 찾는 데 사용된다. 이 정리는 여러 개의 다른 모듈로에 대해 서로 다른 나머지를 가지는 정수 x를 찾는 문제에 적용될 수 있다.

예를 들어, x가 3으로 나누었을 때는 2가 남고, 5로 나누었을 때는 3이 남는 숫자를 찾고 싶다고 가정하자. 이 경우에는 중국인의 나머지 정리를 사용하여 이러한 조건을 만족하는 유일한 x 값을 찾을 수 있다.

존재성 증명에서는 두 방정식을 만족하는 x의 구체적인 형태를 제공하고, 유일성 증명에서는 두 방정식을 만족하는 어떤 두 수도 서로 동등함을 보여준다. 이러한 원리는 컴퓨터 알고리즘 설계와 암호학에서 특정한 종류의 문제를 해결하기 위해 중요하게 사용된다. 예를 들어, 여러 개의 서로 다른 기준으로 정보를 분산시키고자 할 때 중국인의 나머지 정리를 통해 이 정보를 효과적으로 재조합할 수 있다.
#### 예시
$\mathbb{Z}_{105}$에서 $x ≡ 3 \pmod{7}$이고 $x ≡ 5 \pmod{15}$인 $x$를 찾으시오.

- $105 = 15 * 7$, $\gcd (15, 7) = 1$
- $p = 7, q = 15$로 둡니다.
- $M_q$는 $q^{-1} \pmod{p}$이고, 여기서는 $15^{-1} \pmod{7} = 1$입니다. (왜냐하면 15를 7로 나눈 나머지는 1이고 1의 역원은 1입니다.)
- $M_p$는 $p^{-1} \pmod{q}$이고, 여기서는 $7^{-1} \pmod{15} = 13$입니다. (왜냐하면 $7 * 13 = 91$은 15로 나눈 나머지가 1이기 때문입니다.)
- $x$는 $a * q * M_q + b * p * M_p$로 계산할 수 있으며, $x = 3 * 15 * 1 + 5 * 7 * 13 = 500$이고, 이를 105로 나눈 나머지는 80입니다.

#### 추가 설명

중국인의 나머지 정리를 활용한 이 예시는 두 개의 서로 다른 합동식을 만족하는 x의 값을 찾는 방법을 보여줍니다. 여기서 p와 q는 서로소이며, 각각의 합동식 $x ≡ 3 \pmod{7}$과 $x ≡ 5 \pmod{15}$에서 나머지를 각각 3과 5로 가집니다.

먼저, 주어진 mod p와 mod q에 대해 각각의 역원을 찾습니다. $M_q = 15^{-1} \pmod{7}$에서 15와 7은 서로소이므로 15의 7에 대한 모듈러 역원은 1입니다. $M_p = 7^{-1} \pmod{15}$에서도 마찬가지로 7의 15에 대한 모듈러 역원은 13입니다. 이 역원들을 사용하여 x 값을 계산합니다.

그 결과로 나온 x = 500을 주어진 105로 나눈 나머지는 80이므로, 이 값은 주어진 두 합동식을 모두 만족하는 유일한 해가 됩니다. 이렇게 중국인의 나머지 정리는 여러 개의 모듈러 산술 조건을 만족하는 해를 찾는 데 유용하게 쓰일 수 있습니다.



## 확률적 소수 판정법 I (Probabilistic Primality Test I)
페르마 검사 (Probabilistic Primality Test: Fermat Test)

a를 정수, p를 소수라고 할 때,

$a^p ≡ a (mod p) (\Longleftrightarrow a^{ p-1} ≡ 1 (mod p))$


**알고리즘 5 페르마 소수 판정법**
입력: 후보 $\bar{p}$와 보안 매개변수 λ
출력: "$\bar{p}$ 은 소수이다" 혹은 "$\bar{p}$은 합성수이다"
    
```python title="페르마 소수 판정법, p -> p{bar}"
for i from 1 to λ do
		randomly select a from {2, 3, ..., p - 2}
		if a^{p-1} ≡ 1 (mod p)이 아니라면
				return "p은 합성수이다"
		end if
end for
return "p은 소수이다"
```
    

#### 추가 설명

페르마의 소수 판정법은 주어진 수가 소수인지 합성수인지를 판별하는 확률적 알고리즘이다. 이 방법은 페르마의 소정리를 기반으로 하며, 어떤 수 $\bar{p}$가 소수일 가능성을 평가하기 위해 사용된다. 알고리즘은 보안 매개변수 λ만큼 많은 수의 무작위 테스트를 수행한다. 각 테스트에서, 2와 $\bar{p} - 2$ 사이의 무작위 수 a를 선택하고 $a^{\bar{p}-1}$을 계산한 후 이 결과가 $\bar{p}$에 대한 모듈로 1과 같은지 확인한다.

만약 $a^{\bar{p}-1} ≡ 1 (mod \bar{p})$이 성립하지 않는 경우가 하나라도 발견되면 $\bar{p}$는 합성수라는 것을 의미하고, 알고리즘은 "$\bar{p}$은 합성수이다"라고 결론지어 실행을 중단한다. 모든 테스트를 통과하면 $\bar{p}$은 높은 확률로 소수라고 할 수 있으며, "$\bar{p}$은 소수이다"라고 결론을 내린다.

이 방법은 확률적이기 때문에, 항상 100% 정확하다고 보장할 수는 없으나, λ를 적절히 크게 선택함으로써 오류의 확률을 매우 낮출 수 있다. 페르마의 소수 판정법은 계산이 비교적 간단하기 때문에 큰 수에 대한 소수 판별에 유용하게 사용될 수 있다.




## 반례: 카마이클 수	(Counterexample: Carmichael Number)

- 정의 (카마이클 수)
카마이클 수 C는 합성수이며 모든 a에 대해 $gcd(a, C) = 1$일 때 다음을 만족하는 수이다.
$a^{C-1} ≡ 1 (mod C)$
- 예시
• $N = 561 = 3 * 11 * 17$
• 모든 a에 대해 $gcd(a, 561) = 1$일 때, $a^{560} ≡ 1 (mod 561)$
• 페르마 검사는 카마이클 수를 소수로 판별한다.
• 대략 10^6 개의 카마이클 수가 10^15 이하에 존재한다.

#### 추가 설명

카마이클 수는 페르마의 소정리의 조건을 만족하는 특별한 종류의 합성수를 의미한다. 즉, $a^{C-1} ≡ 1 (mod C)$를 만족하지만 C 자체는 소수가 아닌 수를 말한다. 이러한 수는 페르마 검사에서 소수로 잘못 판별될 수 있는 '가짜 소수'의 한 예시이다.

카마이클 수는 페르마 검사 같은 소수 판별법에 대한 반례를 제공함으로써, 이러한 검사법들이 항상 완벽하게 정확하지는 않음을 보여준다. 예를 들어, 561과 같은 카마이클 수는 페르마 검사를 통과하지만 실제로는 3, 11, 17의 곱으로 이루어진 합성수이다.

카마이클 수는 상대적으로 드물기 때문에, 대부분의 수에 대해 페르마 검사는 여전히 유용하다. 그러나 카마이클 수의 존재는 소수 판별법을 설계할 때 주의를 기울여야 함을 상기시킨다. 따라서 더 정교한 소수 판별법, 예를 들어 밀러-라빈 검사와 같은 방법들이 카마이클 수에 대해서도 정확하게 소수를 판별할 수 있도록 개발되었다.



## 확률적 소수 판정법 II (Probabilistic Primality Test II)
밀러-라빈 검사 - 아이디어 (Probabilistic Primality Test II: Miller-Rabin Test - Idea)

$\bar{p} - 1 = 2^r * s$ 형태이고 s가 홀수일 때, 만약 어떤 정수 a에 대해

$a^s \neq 1 \pmod{\bar{p}}$이고 $a^{s*2^j} \neq \bar{p} - 1 \pmod{\bar{p}}$가 모든 j에 대해 ${0, 1, ..., r - 1}$이면, 그러면 $\bar{p}$은 합성수이다. 

그렇지 않다면, $\bar{p}$은 아마도 소수일 것이다.

- 예시
	- $\bar{p} = 561 = 3 * 11 * 17$
	- $\bar{p} - 1 = 560 = 2^4 * 35$

$5^{35} ≡ 23 \pmod {561}$
$5^{35*2} ≡ 529 \pmod {561}$
$5^{35*2^2} ≡ 529^2 ≡ 463 \pmod {561}$
$5^{35*2^3} ≡ 463^2 ≡ 67 \pmod {561}$
$\Longrightarrow $ 561은 합성수이다!

#### 추가 설명
검사 방법은 다음과 같다: 주어진 후보 $\bar{p}$을 $\bar{p} - 1 = 2^r * s $형태로 표현한다. 이때, s는 홀수이다. 그런 다음, $a^s$를 계산하고 이 수가 1 또는 $\bar{p} - 1$과 다를 경우 $a^(s*2), a^(s*2^2), ..., a^{s*2^(r-1)}$의 계산을 이어간다. 이 수들 중 하나라도 $\bar{p} - 1$과 동일하다면, $\bar{p}$은 소수일 가능성이 높다. 그러나 이 모든 수가 $\bar{p}$ - 1과 다르다면 $\bar{p}$은 합성수이다.

이 예시에서는 561을 검사할 때 5를 기반으로 한 검사를 수행한다. $5^35, 5^(35*2), ..., 5^{35*2^3}$를 계산하고 이 결과가 모두 561 - 1, 즉 560과 다르기 때문에 561은 합성수임이 밝혀졌다. 밀러-라빈 검사는 이러한 방법으로 소수 판별의 정확도를 높이는 데 큰 도움을 준다.

## 밀러-라빈 소수 판정법 설명 (Miller-Rabin Primality Test Explanation)

- 알고리즘 6 밀러-라빈 소수 판정법
입력: 후보 $\bar{p}$와 $\bar{p} - 1 = 2^r * s$ 형태의 s는 홀수, 보안 매개변수 λ
출력: "$\bar{p}$은 소수이다" 혹은 "$\bar{p}$은 합성수이다"
    
```python title="밀러-라빈 소수 판정법, p -> p{bar}"
for i from 1 to λ do
		randomly select a from {2, 3, ..., p - 2}
		z = a^s (mod p)
		if z ≠ 1 and z ≠ p - 1이라면
				for j from 1 to r - 1 do
						z = z^2 (mod p)
						if z = 1이라면
								return "p은 합성수이다"
						end if
						if z = p - 1이라면
								break
						end if
				end for
				if z ≠ p - 1이라면
						return "p은 합성수이다"
				end if
		end if
end for
return "p은 소수이다"
```

최악의 경우 실패 확률은 $4^{-λ}$이다.

#### 추가 설명

밀러-라빈 소수 판정법은 확률적 알고리즘으로, 정해진 횟수 λ만큼 반복하여 주어진 수 $\bar{p}$가 소수일 가능성을 테스트한다. 각 반복마다, 무작위로 선택된 a에 대해 몇 가지 계산을 수행하여 $\bar{p}$가 소수인지를 판별한다.

이 알고리즘은 $\bar{p} - 1 = 2^r * s$와 같이 표현될 때 s가 홀수인 경우에 작동한다. 먼저, $a^s (mod \bar{p})$를 계산하고, 그 결과가 1 또는 $\bar{p}$ - 1이 아니면 $z^2$를 반복적으로 계산한다. 이 과정에서 z가 1로 돌아오면 $\bar{p}$는 합성수임이 확실하다. 만약 $z^2$를 r - 1번 계산하는 동안 $\bar{p}$ - 1이 나타나지 않는다면, $\bar{p}$는 합성수이다. 이 모든 테스트를 통과하면 $\bar{p}$은 소수일 가능성이 높다.

밀러-라빈 검사는 페르마의 소수 판정법보다 더 정확하며, 특히 카마이클 수와 같은 특별한 합성수들을 걸러낼 수 있는 장점이 있다. 그러나 이 방법도 확률적이기 때문에 소수 판정에 대한 절대적인 확신을 줄 수는 없다. 하지만, 보안 매개변수 λ를 크게 설정함으로써, 오류 확률을 충분히 낮출 수 있다.

