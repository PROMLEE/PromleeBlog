# 공개 키 암호화 개요 (Overview of Public Key Cryptography)
## 공개 키 암호화란? (What is Public Key Cryptography?)
암호화에 사용되는 키와 복호화를 위한 키는 다르다.
RSA, ElGamal, NTRU 등이 있다.
장점: 키 공유가 쉽고, 키의 수가 적다.
단점: 대칭키 암호화보다 느리다.

## 공개 키 암호화의 정의 (Definition of Public Key Cryptography)
정의: 공개 키 암호화 PKE는 다음과 같은 알고리즘들로 구성된다.
- KeyGen(λ): 보안 파라미터 λ를 입력으로 받아 (pk, sk)를 출력한다.
- Enc(pk, M): 공개 키 pk와 평문 M을 입력으로 받아 암호문 C을 출력한다.
- Dec(sk, C): 개인 키 sk와 암호문 C을 입력으로 받아 평문 M을 출력한다.

정확성
공개 키 암호화 PKE는 다음이 성립할 때 정확하다고 한다. 보안 파라미터 λ와 모든 평문 M에 대해,
<Bbox>$$ Dec(sk, Enc(pk, M)) = M $$</Bbox>
여기서 (pk, sk)는 KeyGen(λ)의 출력이다.

## 공개 키 암호화를 위한 보안 모델 (Security Model for Public Key Cryptography)
도전자 C와 적대자 A 사이의 게임을 고려하자
A의 목표는 공개 키 암호화를 해독하는 것이다. - 즉, 암호문에서 평문 M을 찾는 것이다.

1. Setup : 도전자 C는 보안 파라미터 λ를 입력으로 받아 (pk, sk)를 출력한다.

	그 중, 공개 키 pk를 A에게 전달한다.
2. Phase1: A는 C에게 복호화 쿼리 요청을 보낸다.

	즉, A는 임의의 암호문 $C_i$를 C에게 보내고, C는 $Dec(sk, C_i) = M_i$을 반환한다.
3. Challenge: A는 두 평문 $M_0, M_1$을 선택하고, C는 둘 중 하나를 선택해($b \in \{1, 2\}$) $Enc(pk, M_b) = C_b$를 반환한다.

	이때, A는 어떤 평문에 해당하는 암호문인지 $b$를 추측한다.
4. Phase2: A는 C에게 복호화 쿼리 요청을 보낸다.

	즉, A는 임의의 암호문 $C_i$를 C에게 보내고, C는 $Dec(sk, C_i) = M_i$을 반환한다.
- A는 $b$를 추측하고, 이 추측이 맞는지 확인한다.

$Adv_{PKE}(\lambda) = Pr[b = b'] - \frac{1}{2}$

<Ybox>

공개 키 암호화 체계는 적이 보안 파라미터에서 중요하지 않은 이점을 가질 수 없을 때 IND-XXX 안전하다.
</Ybox>
XXX: 적대자에게 허용된 복호화 오라클에 의해 결정된다.
- CPA(Ciphertext Only Attack): 암호문만을 이용하여 평문을 찾는 공격
- CCA(Chosen Ciphertext Attack): 임의의 암호문을 복호화하는 공격
- CCA2: 암호문을 복호화하는 공격과 복호화 오라클을 이용하는 공격


# 핵심 수론 (Essential Number Theory)
## RSA: 키 생성 (RSA: Key Generation)
1. 두 개의 큰 소수 p, q를 선택한다.
2. $N = p * q$를 계산한다.
3. $\phi(N) = (p - 1)(q - 1)$를 계산한다.
4. $e$를 선택한다. (단, $1 < e < \phi(N)$이고, $gcd(e, \phi(N)) = 1$이어야 한다.)
5. $d * e= 1 \pmod{\phi(N)}$를 만족하는 비밀 키 $d$를 계산한다.
6. 공개 키 $pk$는 $(N, e)$이고, 비밀 키 $sk$는 $(N, d)$이다.

## RSA: 암호화 & 복호화 (RSA: Encryption & Decryption)
- 암호화
	- 공개 키 $pk = (N, e)$와 평문 $M$을 입력으로 받는다.
	- $C := RSA.Enc(pk, M) = M^e \pmod{N}$을 계산한다.
	- $C$를 반환한다.
- 복호화
	- 비밀 키 $sk = (N, d)$와 암호문 $C$를 입력으로 받는다.
	- $M' := RSA.Dec(sk, C) = C^d \pmod{N}$을 계산한다.
	- $M'$을 반환한다.

## 모듈러 지수승 (Modular Exponentiation)
$g^a \pmod{p}$를 계산하는 방법
Naive 한 방법 : (a-1)번의 곱셈이 필요하다.
### 왼쪽에서 오른쪽 모듈러 지수승(L2RME)
입력: $g, a = (a_{l-1}, a_{l-2}, ... , a_1, a_0)_2, p$

출력: $g^a \pmod{p}$

```python title="왼쪽에서 오른쪽 모듈러 지수승"
R = 1
for i from l - 1 down to 0 do
		R = R^2 (mod p)
		if a_i = 1 then
				R = R * g (mod p)
		end if
end for
return R
```
#### 예시
$4^{25} \pmod{31}$을 계산하시오.
- $25 = (11001)_2$ -> a를 2진수로 변환, $l = 5$
- $a_4 = 1, a_3 = 1, a_2 = 0, a_1 = 0, a_0 = 1$
- $a_4 = 1$이므로 $R = 1^2 * 4 \pmod{31} = 4$
- $a_3 = 1$이므로 $R = 4^2*4 \pmod{31} = 2$
- $a_2 = 0$이므로 $R = 2^2 \pmod{31} = 4$
- $a_1 = 0$이므로 $R = 4^2 \pmod{31} = 16$
- $a_0 = 1$이므로 $R = 16^2*4 \pmod{31} = 29$
- 따라서, $4^{25} \pmod{31} = 29$

$log_2a + HW(a) - 1$번의 곱셈이 필요하다.

$HW(a)$는 a의 비트 중 1의 개수이다.

### 오른쪽에서 왼쪽 모듈러 지수승(R2LME)
입력: $g, a = (a_{l-1}, a_{l-2}, ... , a_1, a_0)_2, p$
출력: $g^a \pmod{p}$

```python title="오른쪽에서 왼쪽 모듈러 지수승"
R = 1, T = g
for i from 0 to l - 2 do
		if a_i = 1 then
				R = R * T (mod p)
		end if
		T = T^2 (mod p)
end for
R = R * T (mod p)
return R
```
#### 예시
$4^{25} \pmod{31}$을 계산하시오.
- $25 = (11001)_2$ -> a를 2진수로 변환, $l = 5$
- $a_0 = 1$이므로 $R = 1 * 4 \pmod{31} = 4, T = 4$
- $a_1 = 0$이므로 $R = 4, T = 4^2 \pmod{31} = 16$
- $a_2 = 0$이므로 $R = 4, T = 16^2 \pmod{31} = 25$
- $a_3 = 1$이므로 $R = 4 * 25 \pmod{31} = 29, T = 25^2 \pmod{31} = 4$
- $a_4 = 1$이므로 $R = 29 * 4 \pmod{31} = 29$
- 따라서, $4^{25} \pmod{31} = 29$

$log_2a + HW(a) - 1$번의 곱셈이 필요하다.

$HW(a)$는 a의 비트 중 1의 개수이다.

## 정수 위의 유클리드 알고리즘 (Euclidean Algorithm on Integers)
> a와 b가 양의 정수이고 a > b일 때, $\gcd(a, b) = \gcd(b, a \pmod{b})$이다.

### 정수 위의 유클리드 알고리즘(Euclidean Algorithm on Integers)
입력: 두 양의 정수 a, b (a >= b)
출력: a와 b의 최대공약수

```pseudo title="정수 위의 유클리드 알고리즘"
r = a, r' = b
while r' != 0 do
		r'' = r mod r'
		r = r'
		r' = r''
end while
d = r
return d
```
#### 예시
$\gcd(48, 18)$을 계산하시오.
- $48 = 18 * 2 + 12$
- $18 = 12 * 1 + 6$
- $12 = 6 * 2 + 0$
- 따라서, $\gcd(48, 18) = 6$

## 확장된 유클리드 알고리즘 (Extended Euclidean Algorithm)
> $a, b, r$이 양의 정수이고 $d = \gcd(a, b)$일 때, $ax + by = d$이 성립하며 
$x, y \in \mathbb{Z}$는 $d|r$일 때 존재한다.($d|r$은 $d$가 $r$을 나눈다는 의미이다.)

입력: 두 양의 정수 $a, b (a >= b)$
출력: $a$와 $b$의 최대공약수 d와 $d = ax + by$를 만족하는 $x, y$

```pseudo title="확장된 유클리드 알고리즘"
r = a, r' = b, x = 1, y = 0, x' = 0, y' = 1
while r' != 0 do
		q = r // r'
		r'' = r mod r'
		(r, x, y, r', x', y') = (r', x', y', r'', x - q * x', y - q * y')
end while
d = r
return d, x, y
```

예시: $\gcd(48, 18)$을 계산하시오.
- $r = 48, r' = 18, x = 1, y = 0, x' = 0, y' = 1$
- $q = 48 // 18 = 2, r'' = 48 mod 18 = 12$, $(r, x, y, r', x', y')\\
	= (18, 0, 1, 12, 1 - 2 * 0, 0 - 2 * 1) = (18, 0, 1, 12, 1, -2)$
- $q = 18 // 12 = 1, r'' = 18 mod 12 = 6$, $(r, x, y, r', x', y')\\
	= (12, 1, -2, 6, 0 - 1 * 1, 1 - 1 * -2) = (12, 1, -2, 6, -1, 3)$
- $q = 12 // 6 = 2, r'' = 12 mod 6 = 0$, $(r, x, y, r', x', y')\\
	= (6, -1, 3, 0, 1 - 2 * -1, -2 - 2 * 3) = (6, -1, 3, 0, 3, -8)$
- 따라서, $\gcd(48, 18) = 6$이고, $6 = -1 * 48 + 3 * 18$이다.

## 오일러 파이 함수 (Euler's Phi Function)
> 오일러 파이 함수 $\phi(n)$은 $\mathbb{Z}_m$에서 m과 서로소인 수의 개수를 의미한다.

$m = p_1^{e_1} * p_2^{e_2} * ... * p_n^{e_n}$ 일 때(이때, $p_i$는 서로 다른 소수, $e_i$는 양의 정수), $\phi(n)$은 다음과 같이 계산할 수 있다.
<Bbox>

$\phi(n) = \prod _{i=1}^{n}(p_i^{e_i} - p_i^{e_i-1})$
</Bbox>

$\phi(p) = p - 1$ (p는 소수)

#### 예시
1. $\phi(6) = 2$ (6과 서로소인 수는 1, 5), $\phi(8) = 4$ (8과 서로소인 수는 1, 3, 5, 7)
2. $m = 240$ 이라 하면, $240 = 2^4 * 3^1 * 5^1$이므로

$\phi(240) = (2^4 - 2^3) * (3^1 - 3^0) * (5^1 - 5^0) = 64$

## 페르마의 소정리 (Fermat's Little Theorem)
<Bbox>

정수$a$, 소수 $p$ 에 대하여, $a^{p} \equiv a \pmod{p}$, $a^{-1}\equiv a^{p-2} \pmod{p}$이다.
</Bbox>


#### 예시
1. $p = 7, a = 2$일 때, $2^7 \equiv 2 \pmod{7}$이다.
2. $p = 11, a = 3$일 때, $3^{11} \equiv 3 \pmod{11}$이다.

### 따름정리
<Bbox>

정수 $a$, 소수 $p$에 대하여, $a^{p-1} \equiv 1 \pmod{p}$이다.
또한, $a^{-1} = a^{p-2} \pmod{p}$이다.
</Bbox>

#### 증명
$a\times a \times a \times ... \times a \equiv a \times a \times a \times ... \times a \pmod{p}$이므로, <MathBox>$a^{p-1} \equiv 1 \pmod{p}$</MathBox>이다.
$a \times a^{-1} \equiv 1 \pmod{p}$이므로, <MathBox>$\mathbf{a^{-1} = a^{p-2} \pmod{p}}$</MathBox>이다.


## 오일러 정리 (Euler's Theorem)
<Bbox>

서로 소로수인 정수 $a$, 정수 $m$에 대하여, $a^{\phi(m)} \equiv 1 \pmod{m}$이다.
</Bbox>

#### 예시
$a = 5, m = 12$ 일 때, $\phi(12) = \phi(2^2 * 3^1) = (2^2 - 2^1) * (3^1 - 3^0) = 4$이다.
$\because (1, 5, 7, 11)$
따라서, $5^4 \equiv 1 \pmod{12}$이다.

## 중국인의 나머지 정리 (Chinese Remainder Theorem)
<Bbox>

$p$와 $q$가 서로소일 때, 두 방정식
$x ≡ a \pmod{p}$
$x ≡ b \pmod{p}$
은 $pq$에 대한 $X$의 유일한 해를 가진다.
</Bbox>

#### 증명
1. 존재성:

	$x = a \times q \times M_q + b \times p \times M_p \pmod{pq}$

	여기서 $M_q$는 $q^{-1} \pmod{p}$이고, $M_p$는 $p^{-1} \pmod{q}$이다.

2. 유일성:

	만약 $x ≡ y \pmod{p}$이고 $x ≡ y \pmod{q}$라면, $x - y$는 $p$와 $q$의 배수이다. 
	
	따라서, $x - y$는 $pq$의 배수이며 $x ≡ y \pmod{pq}$이다.

#### 추가 설명

중국인의 나머지 정리는 두 개 이상의 서로소인 모듈러 산술 시스템에서 유일한 해를 찾는 데 사용된다. 이 정리는 여러 개의 다른 모듈로에 대해 서로 다른 나머지를 가지는 정수 x를 찾는 문제에 적용될 수 있다.

예를 들어, x가 3으로 나누었을 때는 2가 남고, 5로 나누었을 때는 3이 남는 숫자를 찾고 싶다고 가정하자. 이 경우에는 중국인의 나머지 정리를 사용하여 이러한 조건을 만족하는 유일한 x 값을 찾을 수 있다.

존재성 증명에서는 두 방정식을 만족하는 x의 구체적인 형태를 제공하고, 유일성 증명에서는 두 방정식을 만족하는 어떤 두 수도 서로 동등함을 보여준다. 이러한 원리는 컴퓨터 알고리즘 설계와 암호학에서 특정한 종류의 문제를 해결하기 위해 중요하게 사용된다. 예를 들어, 여러 개의 서로 다른 기준으로 정보를 분산시키고자 할 때 중국인의 나머지 정리를 통해 이 정보를 효과적으로 재조합할 수 있다.
#### 예시
$\mathbb{Z}_{105}$에서 $x ≡ 3 \pmod{7}$이고 $x ≡ 5 \pmod{15}$인 $x$를 찾으시오.

- $105 = 15 * 7$, $\gcd (15, 7) = 1$
- $p = 7, q = 15$로 둡니다.
- $M_q$는 $q^{-1} \pmod{p}$이고, 여기서는 $15^{-1} \pmod{7} = 1$입니다. (왜냐하면 15를 7로 나눈 나머지는 1이고 1의 역원은 1입니다.)
- $M_p$는 $p^{-1} \pmod{q}$이고, 여기서는 $7^{-1} \pmod{15} = 13$입니다. (왜냐하면 $7 * 13 = 91$은 15로 나눈 나머지가 1이기 때문입니다.)
- $x$는 $a * q * M_q + b * p * M_p$로 계산할 수 있으며, $x = 3 * 15 * 1 + 5 * 7 * 13 = 500$이고, 이를 105로 나눈 나머지는 80입니다.

#### 추가 설명

중국인의 나머지 정리를 활용한 이 예시는 두 개의 서로 다른 합동식을 만족하는 x의 값을 찾는 방법을 보여줍니다. 여기서 p와 q는 서로소이며, 각각의 합동식 $x ≡ 3 \pmod{7}$과 $x ≡ 5 \pmod{15}$에서 나머지를 각각 3과 5로 가집니다.

먼저, 주어진 mod p와 mod q에 대해 각각의 역원을 찾습니다. $M_q = 15^{-1} \pmod{7}$에서 15와 7은 서로소이므로 15의 7에 대한 모듈러 역원은 1입니다. $M_p = 7^{-1} \pmod{15}$에서도 마찬가지로 7의 15에 대한 모듈러 역원은 13입니다. 이 역원들을 사용하여 x 값을 계산합니다.

그 결과로 나온 x = 500을 주어진 105로 나눈 나머지는 80이므로, 이 값은 주어진 두 합동식을 모두 만족하는 유일한 해가 됩니다. 이렇게 중국인의 나머지 정리는 여러 개의 모듈러 산술 조건을 만족하는 해를 찾는 데 유용하게 쓰일 수 있습니다.



## 확률적 소수 판정법 I (Probabilistic Primality Test I)
페르마 검사 (Probabilistic Primality Test: Fermat Test)

a를 정수, p를 소수라고 할 때,

$a^p ≡ a (mod p) (\Longleftrightarrow a^{ p-1} ≡ 1 (mod p))$


**알고리즘 5 페르마 소수 판정법**
입력: 후보 $\bar{p}$와 보안 매개변수 λ
출력: "$\bar{p}$ 은 소수이다" 혹은 "$\bar{p}$은 합성수이다"
    
```python title="페르마 소수 판정법, p -> p{bar}"
for i from 1 to λ do
		randomly select a from {2, 3, ..., p - 2}
		if a^{p-1} ≡ 1 (mod p)이 아니라면
				return "p은 합성수이다"
		end if
end for
return "p은 소수이다"
```
    

#### 추가 설명

페르마의 소수 판정법은 주어진 수가 소수인지 합성수인지를 판별하는 확률적 알고리즘이다. 이 방법은 페르마의 소정리를 기반으로 하며, 어떤 수 $\bar{p}$가 소수일 가능성을 평가하기 위해 사용된다. 알고리즘은 보안 매개변수 λ만큼 많은 수의 무작위 테스트를 수행한다. 각 테스트에서, 2와 $\bar{p} - 2$ 사이의 무작위 수 a를 선택하고 $a^{\bar{p}-1}$을 계산한 후 이 결과가 $\bar{p}$에 대한 모듈로 1과 같은지 확인한다.

만약 $a^{\bar{p}-1} ≡ 1 (mod \bar{p})$이 성립하지 않는 경우가 하나라도 발견되면 $\bar{p}$는 합성수라는 것을 의미하고, 알고리즘은 "$\bar{p}$은 합성수이다"라고 결론지어 실행을 중단한다. 모든 테스트를 통과하면 $\bar{p}$은 높은 확률로 소수라고 할 수 있으며, "$\bar{p}$은 소수이다"라고 결론을 내린다.

이 방법은 확률적이기 때문에, 항상 100% 정확하다고 보장할 수는 없으나, λ를 적절히 크게 선택함으로써 오류의 확률을 매우 낮출 수 있다. 페르마의 소수 판정법은 계산이 비교적 간단하기 때문에 큰 수에 대한 소수 판별에 유용하게 사용될 수 있다.




## 반례: 카마이클 수	(Counterexample: Carmichael Number)

- 정의 (카마이클 수)
카마이클 수 C는 합성수이며 모든 a에 대해 $gcd(a, C) = 1$일 때 다음을 만족하는 수이다.
$a^{C-1} ≡ 1 (mod C)$
- 예시
• $N = 561 = 3 * 11 * 17$
• 모든 a에 대해 $gcd(a, 561) = 1$일 때, $a^{560} ≡ 1 (mod 561)$
• 페르마 검사는 카마이클 수를 소수로 판별한다.
• 대략 10^6 개의 카마이클 수가 10^15 이하에 존재한다.

#### 추가 설명

카마이클 수는 페르마의 소정리의 조건을 만족하는 특별한 종류의 합성수를 의미한다. 즉, $a^{C-1} ≡ 1 (mod C)$를 만족하지만 C 자체는 소수가 아닌 수를 말한다. 이러한 수는 페르마 검사에서 소수로 잘못 판별될 수 있는 '가짜 소수'의 한 예시이다.

카마이클 수는 페르마 검사 같은 소수 판별법에 대한 반례를 제공함으로써, 이러한 검사법들이 항상 완벽하게 정확하지는 않음을 보여준다. 예를 들어, 561과 같은 카마이클 수는 페르마 검사를 통과하지만 실제로는 3, 11, 17의 곱으로 이루어진 합성수이다.

카마이클 수는 상대적으로 드물기 때문에, 대부분의 수에 대해 페르마 검사는 여전히 유용하다. 그러나 카마이클 수의 존재는 소수 판별법을 설계할 때 주의를 기울여야 함을 상기시킨다. 따라서 더 정교한 소수 판별법, 예를 들어 밀러-라빈 검사와 같은 방법들이 카마이클 수에 대해서도 정확하게 소수를 판별할 수 있도록 개발되었다.



## 확률적 소수 판정법 II (Probabilistic Primality Test II)
밀러-라빈 검사 - 아이디어 (Probabilistic Primality Test II: Miller-Rabin Test - Idea)

$\bar{p} - 1 = 2^r * s$ 형태이고 s가 홀수일 때, 만약 어떤 정수 a에 대해

$a^s \neq 1 \pmod{\bar{p}}$이고 $a^{s*2^j} \neq \bar{p} - 1 \pmod{\bar{p}}$가 모든 j에 대해 ${0, 1, ..., r - 1}$이면, 그러면 $\bar{p}$은 합성수이다. 

그렇지 않다면, $\bar{p}$은 아마도 소수일 것이다.

- 예시
	- $\bar{p} = 561 = 3 * 11 * 17$
	- $\bar{p} - 1 = 560 = 2^4 * 35$

$5^{35} ≡ 23 \pmod {561}$
$5^{35*2} ≡ 529 \pmod {561}$
$5^{35*2^2} ≡ 529^2 ≡ 463 \pmod {561}$
$5^{35*2^3} ≡ 463^2 ≡ 67 \pmod {561}$
$\Longrightarrow $ 561은 합성수이다!

#### 추가 설명
검사 방법은 다음과 같다: 주어진 후보 $\bar{p}$을 $\bar{p} - 1 = 2^r * s $형태로 표현한다. 이때, s는 홀수이다. 그런 다음, $a^s$를 계산하고 이 수가 1 또는 $\bar{p} - 1$과 다를 경우 $a^(s*2), a^(s*2^2), ..., a^{s*2^(r-1)}$의 계산을 이어간다. 이 수들 중 하나라도 $\bar{p} - 1$과 동일하다면, $\bar{p}$은 소수일 가능성이 높다. 그러나 이 모든 수가 $\bar{p}$ - 1과 다르다면 $\bar{p}$은 합성수이다.

이 예시에서는 561을 검사할 때 5를 기반으로 한 검사를 수행한다. $5^35, 5^(35*2), ..., 5^{35*2^3}$를 계산하고 이 결과가 모두 561 - 1, 즉 560과 다르기 때문에 561은 합성수임이 밝혀졌다. 밀러-라빈 검사는 이러한 방법으로 소수 판별의 정확도를 높이는 데 큰 도움을 준다.

## 밀러-라빈 소수 판정법 설명 (Miller-Rabin Primality Test Explanation)

- 알고리즘 6 밀러-라빈 소수 판정법
입력: 후보 $\bar{p}$와 $\bar{p} - 1 = 2^r * s$ 형태의 s는 홀수, 보안 매개변수 λ
출력: "$\bar{p}$은 소수이다" 혹은 "$\bar{p}$은 합성수이다"
    
```python title="밀러-라빈 소수 판정법, p -> p{bar}"
for i from 1 to λ do
		randomly select a from {2, 3, ..., p - 2}
		z = a^s (mod p)
		if z ≠ 1 and z ≠ p - 1이라면
				for j from 1 to r - 1 do
						z = z^2 (mod p)
						if z = 1이라면
								return "p은 합성수이다"
						end if
						if z = p - 1이라면
								break
						end if
				end for
				if z ≠ p - 1이라면
						return "p은 합성수이다"
				end if
		end if
end for
return "p은 소수이다"
```

최악의 경우 실패 확률은 $4^{-λ}$이다.

#### 추가 설명

밀러-라빈 소수 판정법은 확률적 알고리즘으로, 정해진 횟수 λ만큼 반복하여 주어진 수 $\bar{p}$가 소수일 가능성을 테스트한다. 각 반복마다, 무작위로 선택된 a에 대해 몇 가지 계산을 수행하여 $\bar{p}$가 소수인지를 판별한다.

이 알고리즘은 $\bar{p} - 1 = 2^r * s$와 같이 표현될 때 s가 홀수인 경우에 작동한다. 먼저, $a^s (mod \bar{p})$를 계산하고, 그 결과가 1 또는 $\bar{p}$ - 1이 아니면 $z^2$를 반복적으로 계산한다. 이 과정에서 z가 1로 돌아오면 $\bar{p}$는 합성수임이 확실하다. 만약 $z^2$를 r - 1번 계산하는 동안 $\bar{p}$ - 1이 나타나지 않는다면, $\bar{p}$는 합성수이다. 이 모든 테스트를 통과하면 $\bar{p}$은 소수일 가능성이 높다.

밀러-라빈 검사는 페르마의 소수 판정법보다 더 정확하며, 특히 카마이클 수와 같은 특별한 합성수들을 걸러낼 수 있는 장점이 있다. 그러나 이 방법도 확률적이기 때문에 소수 판정에 대한 절대적인 확신을 줄 수는 없다. 하지만, 보안 매개변수 λ를 크게 설정함으로써, 오류 확률을 충분히 낮출 수 있다.



# RSA Encryption (RSA 암호화)
## RSA 암호화 개요 (Overview of RSA Encryption)
N은 두 소수 p, q의 곱이다. 즉, $N = p * q$이다.
그 후, 주요 문제는 p와 q를 찾는 것이다.
- 1978년에 Rivest, Shamir, Adleman에 의해 설계되었다.
- 가장 인기 있고 널리 사용되는 공개 키 암호화 체계다.
- 인수 분해의 어려움에 기반하고 있다.
- 암호화 및 복호화 알고리즘은 모듈러 지수화로 이루어져 있다.
- 결정론적 암호화는 IND-XXX 보안을 달성할 수 없다.
- 실제로는 RSA 암호화의 변형(예: RSA-OAEP)을 사용한다.
- 양자 공격에 대해서는 안전하지 않다.

## RSA: 키 생성 (RSA: Key Generation)
1. 두 개의 소수를 선택합니다. 이 두 소수를 p와 q라고 한다.
2. $N = p * q$를 계산합니다.
3. $\phi(N) = (p-1) * (q-1)$를 계산합니다. $\phi(N)$은 N과 서로소인 수의 개수를 의미함
4. $e$를 선택합니다. $1 < e < \phi(N)$이며, $e$와 $\phi(N)$은 서로소여야 함.
5. $d$를 계산합니다. $d$는 $d * e \equiv 1 \pmod{\phi(N)}$을 만족하는 수이다.
6. 공개키$pk$는 $(N, e)$이며, 개인키$sk$는 $d$이다.

#### 추가 설명
- RSA 암호에서 키 생성 과정은 암호화와 복호화가 가능하게 하는 중요한 단계다.
- 소수 $ p$와 $ q$를 곱하여 $ N$을 생성하는 것은 RSA 암호의 기본이 되는 큰 수를 만드는 과정이다.
- $ \phi(N)$은 오일러의 피 함수로, $ N$보다 작으면서 $ N$과 서로소인 정수의 개수를 나타낸다.
- 공개 지수 $ e$는 암호화에 사용되며, 개인 키 $ d$와 함께 중요한 역할을 한다.
- $ d \cdot e \equiv 1 \ (\text{mod} \ \phi(N))$는 개인 키와 공개 지수가 서로 역원 관계임을 보장하는 식이다.
- 확장 유클리드 알고리즘은 이러한 역원을 효율적으로 찾는 데 사용된다.
- 이러한 과정을 통해 생성된 키들은 RSA 암호화에서 데이터를 안전하게 암호화하고 복호화하는 데 필수적이다.

## RSA: 암호화 & 복호화 (RSA: Encryption & Decryption)
### 암호화
공개 키 $pk = (N, e)$와 평문 $M \in \mathbb{Z}_N$이 주어졌을 때, 
$C := RSA.Enc(pk, M) = M^e \ (\text{mod} \ N)$
를 계산하고 $C$를 출력한다.
### 복호화
개인 키 $sk = d$와 암호문 $C \in \mathbb{Z}_N$이 주어졌을 때, 
$M' := RSA.Dec(sk, C) = C^d \ (\text{mod} \ N)$
를 계산하고 $M'$를 출력한다.

#### 추가설명
- RSA 암호화는 주어진 평문 $M$을 공개 키 $e$와 모듈로 $N$을 사용하여 거듭제곱함으로써 암호문 $C$로 변환하는 과정이다.
- 이러한 과정은 평문을 암호화할 때 사용된다. 이 때, 모듈로 $N$이란, 계산 결과를 $N$으로 나눈 나머지를 사용한다는 의미다.
- 복호화는 암호문 $C$를 개인 키 $d$를 사용하여 다시 원래의 평문 $M'$로 변환하는 과정이다.
- 암호화와 복호화 모두 모듈로 $N$을 기반으로 한 거듭제곱 연산을 필요로 하며, 이는 컴퓨터가 큰 수의 연산을 효율적으로 수행할 수 있게 해주는 중요한 알고리즘에 기초한다.
- $M^e$와 $C^d$의 연산이 가능한 이유는 공개 키와 개인 키가 서로 수학적으로 연관되어 있기 때문이며, 이는 RSA 키 생성 과정에서 보장된다.

## RSA의 정확성	(Correctness of RSA)
공개 키 암호화 PKE는 다음이 성립할 때 정확하다고 한다. 보안 파라미터 λ와 모든 평문 M에 대해,
$$ Dec(sk, Enc(pk, M)) = M $$
여기서 (pk, sk)는 KeyGen(λ)의 출력이다.

RSA의 정확성:
$$ M' = RSA.Dec(sk, RSA.Enc(pk, M)) $$
$$ = C^d = (M^e)^d = M^{ed} = M^{s\phi(N) + 1} \mod N $$
$$ = (M^{\phi(N)})^s \cdot M = M (\because \text{오일러 정리})$$

#### 추가 설명

- **공개 키 암호화의 정확성**: 공개 키 암호화 체계는 암호화와 복호화 과정을 거친 후 원래의 메시지 M을 정확히 복원할 수 있어야 한다. 이는 시스템이 실용적으로 사용될 수 있는 기본적인 조건이다.
- **RSA 알고리즘의 작동 원리**: RSA 암호화 과정에서는 메시지 M을 공개키 e를 이용하여 $M^e \mod N$로 암호화하고, 개인키 d를 사용하여 복호화 과정에서 $(M^e)^d \mod N$ 연산을 수행한다. 이론적으로 $ed \mod \phi(N)$은 1이 되어야 하며, 이는 오일러의 정리에 기반한다.
- **오일러의 정리**: $\phi(N)$은 N의 오일러 피-함수로, N보다 작은 양의 정수 중 N과 서로소인 수의 개수를 나타낸다. 오일러의 정리에 따르면, 어떤 정수 a와 N이 서로소일 때, $a^{\phi(N)} \equiv 1 \mod N$이 성립한다. RSA에서는 이 성질을 이용하여 암호화와 복호화 과정에서 발생하는 지수 연산을 간소화한다.

RSA 암호체계는 이러한 수학적 원리를 바탕으로 안전하게 정보를 암호화하고 복호화하는 데 사용된다. 이 암호체계의 정확성과 안정성은 다양한 디지털 통신 및 데이터 보안 분야에서 중요한 역할을 한다.


## RSA: 예시 (RSA: Example)
**키 생성**

1. $p = 13, q = 17$
2. $N = 13 \times 17 = 221$
3. $\phi(N) = (13 - 1)(17 - 1) = 12 \times 16 = 192$
4. $e = 5$
5. $d = 77$ (즉, $5 \times 77 = 385 = 1 \mod 192$)

**암호화**

- $M = 3$
- $C = M^e = 3^5 = 243 = 22 \mod 221$

**복호화**

- $C = 22$
- $M' = C^d = 22^{77} = (22^7)^{11} = 61^{11} = 3 \mod 221$

#### 추가 설명

- **키 생성 과정**: RSA 알고리즘의 키 생성은 두 소수 $p$와 $q$를 선택하고, 이 둘을 곱하여 $N$을 생성한다. $\phi(N)$은 $N$의 오일러 피-함수 값으로, $(p-1)(q-1)$을 계산하여 얻는다. 공개키 $e$는 $\phi(N)$과 서로소인 수 중에서 선택되며, 개인키 $d$는 $ed \equiv 1 \mod \phi(N)$을 만족하는 값이다.
- **암호화**: 메시지 $M$을 공개키 $e$를 사용하여 $M^e \mod N$으로 암호화한다. 여기서는 $M = 3$이며, $3^5 = 243$의 계산 결과를 221로 나눈 나머지가 $C$가 된다.
- **복호화**: 암호문 $C$를 개인키 $d$를 사용하여 $C^d \mod N$으로 복호화한다. $C = 22$이며, 이를 $77$승하여 나머지 연산을 수행하면 원래의 메시지 $M$이 복원된다.

이 예제에서 볼 수 있듯이, RSA 알고리즘은 모듈러 산술과 지수적 연산을 기반으로 안전한 키 교환과 암호화, 복호화를 가능하게 한다. 이 과정에서 $N$, $\phi(N)$, $e$, 그리고 $d$의 선택이 중요하며, 이 값들의 정확한 계산이 RSA의 보안성과 성능을 결정짓는다.

## RSA: 빠른 암호화 (RSA: Fast Encryption)
**암호화**

<Bbox>$C := RSA.Enc(pk, M) = M^e \mod N$</Bbox>
- 일반적으로 공개 키 지수 $e$는 대략 $\log_2 N$-비트이다. 따라서 평균적으로 $1.5(\log_2 N)$번의 곱셈이 필요하다.
- 매우 작고 햄밍 가중치가 낮은 $e$를 선택한다. 예를 들어, $e = 3, 17, 2^{16} + 1$

| $e$ | $e$의 이진 문자열 | 곱셈 횟수 |
| --- | --- | --- |
| 3 | 11₂ | 2 |
| 17 | 10001₂ | 5 |
| \(2^{16} + 1\) | 10000 0000 0001₂ | 17 |
- 개인 키 $d$는 거의 전체 비트 길이를 가지지만 $e$는 매우 작다.

**복호화의 빠른 속도를 위한 방법**

- 개인 키 지수 $d$는 Coppersmith 공격에 의해 $N^{0.292}$보다 커야 한다. 따라서 매우 작은 $d$를 사용할 수 없다.
- 중국인의 나머지 정리(Chinese Remainder Theorem, CRT) 사용:
    1. 계산:
        - $d_p = d \mod (p - 1)$
        - $d_q = d \mod (q - 1)$
    2. 계산:
        - $C_{dp} = C^{d_p} \mod p$
        - $C_{dq} = C^{d_q} \mod q$
    3. 계산:
        - $M = C_{dp} \cdot q \cdot M_q + C_{dq} \cdot p \cdot M_p$
        이 과정은 중국인의 나머지 정리를 사용하여 최종 메시지 $M$을 계산한다.

#### 추가 설명

- **공개 키 지수 $e$의 선택**: RSA 암호화의 속도를 높이기 위해서는 공개 키 지수 $e$를 가능한 작게 선택하는 것이 좋다. 햄밍 가중치가 낮은 $e$는 해당 이진수에서 1의 개수가 적은 것을 의미하며, 곱셈 연산의 횟수를 줄일 수 있다. 예를 들어, $e = 3$의 경우 이진수로는 '11'이고, 1이 두 개밖에 없기 때문에 곱셈이 2회만 필요하다.
- **암호화 과정의 계산 복잡도**: RSA에서 $M^e \mod N$을 계산할 때, $e$의 이진수 표현에서 1이 있는 위치에 따라 순차적으로 곱셈을 수행한다. 따라서 $e$의 선택은 암호화 과정의 효율성을 크게 좌우한다.
- **복잡한 계산의 최소화**: 예를 들어, $e = 2^{16} + 1$은 이진수에서 두 개의 1을 포함하고 있으며, 이는 17번의 곱셈이 필요하다고 계산된다. 이러한 큰 수의 곱셈은 비용이 많이 들기 때문에, 작은 $e$를 선택하는 것이 일반적으로 더 효율적이다.

이러한 최적화는 특히 큰 데이터를 다루거나 높은 처리량이 요구되는 애플리케이션에서 RSA 암호화의 성능을 크게 개선할 수 있다.

- **개인 키 지수 $d$의 크기**: $d$가 너무 작으면 Coppersmith 공격 같은 특정 암호 분석 기법에 취약할 수 있다. 따라서 $d$는 일정 크기 이상으로 설정되어야 한다.
- **중국인의 나머지 정리의 활용**: RSA에서 중국인의 나머지 정리를 사용하는 것은 복호화 과정을 더 빠르게 처리하기 위함이다. $p$와 $q$는 소수이며 $N$의 인수이다. 각각 $p$와 $q$에 대해 별도로 복호화 연산을 수행한 후, 이 결과를 합쳐서 원래의 메시지 $M$을 복구한다. 이 방법은 전체 $N$에 대해 연산을 수행하는 것보다 훨씬 빠르다.
- **$C_{dp}$와 $C_{dq}$ 계산의 중요성**: 이 단계에서는 각각 $p$와 $q$ 모듈로 $C$의 $d_p$승과 $d_q$승을 계산한다. 이는 $p$와 $q$ 각각에 대해 복호화를 수행하는 것과 같으며, 각 결과는 중국인의 나머지 정리를 통해 결합된다.

이러한 최적화 기법은 특히 대규모 RSA 시스템에서 복호화 시간을 상당히 단축시키는 데 도움이 된다.

## CRT를 이용한 RSA 복호화 (RSA Decryption using CRT)

- 이전 예제에서의 복호화
    - $N = 221$, $p = 13$, $q = 17$, $d = 77$, $C = 22$
    - 따라서 $M' = C^d = 22^{77} = (22^{11})^{7} \times 22^2 = 61^{11} \times 3 = 3$ (mod 221)
- $d_p = d \mod (p-1)$
    - $d_p = 77 \mod 12 = 5$
- $d_q = d \mod (q-1)$
    - $d_q = 77 \mod 16 = 13$
- $C_{dp} = C^{d_p} \mod p$
    - $C_{dp} = 22^5 \mod 13 = 3$
- $C_{dq} = C^{d_q} \mod q$
    - $C_{dq} = 22^{13} \mod 17 = 3$
- 중국인의 나머지 정리를 사용하여
    - $M = C_{dp} \cdot M_q + C_{dq} \cdot p \cdot M_p$
    - $M = 3 \cdot 14 + 3 \cdot 13 \cdot 10 = 666$
    - $M = 666 \mod 221 = 3$
- 따라서 $M_p = 17^{-1} \mod 13 = 4$ (mod 13), $M_q = 13^{-1} \mod 17 = 4$ (mod 17)

### 추가 설명

이 슬라이드는 RSA 알고리즘의 복호화 과정을 중국인의 나머지 정리(CRT)를 사용하여 효율적으로 계산하는 방법을 설명한다.

- **RSA 알고리즘**은 공개 키 암호화 방식 중 하나로, 두 개의 큰 소수 $p$와 $q$를 사용하여 만든 $N = p \cdot q$와 이를 이용한 복호화 키 $d$로 구성된다.
- 복호화 과정에서 $C^d \mod N$을 직접 계산하는 대신, CRT를 활용하면 $p$와 $q$에서 각각 계산한 결과를 합쳐 최종 결과를 얻을 수 있다. 이는 큰 숫자의 연산을 간소화하여 계산 속도를 향상시킨다.
- **CRT의 사용**은 $C^{d_p} \mod p$와 $C^{d_q} \mod q$의 결과를 각각 더 작은 모듈로 계산하고, 이를 적절히 조합하여 $N$에 대한 나머지를 구한다. 이 예에서는 최종적으로 $M = 3$을 얻는다.

이 방법은 RSA 알고리즘의 복호화를 보다 실용적으로 적용할 수 있게 하여, 보안이 중요한 다양한 전자 통신 및 데이터 저장에서 널리 사용된다.