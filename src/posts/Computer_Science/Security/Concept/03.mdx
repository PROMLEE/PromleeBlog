# 핵심 수론 (Essential Number Theory)
## 오일러 파이 함수 (Euler's Phi Function)
> 오일러 파이 함수 $\phi(n)$은 $\mathbb{Z}_m$에서 m과 서로소인 수의 개수를 의미한다.

$m = p_1^{e_1} * p_2^{e_2} * ... * p_n^{e_n}$ 일 때(이때, $p_i$는 서로 다른 소수, $e_i$는 양의 정수), $\phi(n)$은 다음과 같이 계산할 수 있다.
<Bbox>

$\phi(n) = \prod _{i=1}^{n}(p_i^{e_i} - p_i^{e_i-1})$
</Bbox>

$\phi(p) = p - 1$ (p는 소수)

#### 예시
1. $\phi(6) = 2$ (6과 서로소인 수는 1, 5), $\phi(8) = 4$ (8과 서로소인 수는 1, 3, 5, 7)
2. $m = 240$ 이라 하면, $240 = 2^4 * 3^1 * 5^1$이므로

$\phi(240) = (2^4 - 2^3) * (3^1 - 3^0) * (5^1 - 5^0) = 64$

## 페르마의 소정리 (Fermat's Little Theorem)
<Bbox>

정수$a$, 소수 $p$ 에 대하여, $a^{p} \equiv a \pmod{p}$, $a^{-1}\equiv a^{p-2} \pmod{p}$이다.
</Bbox>


#### 예시
1. $p = 7, a = 2$일 때, $2^7 \equiv 2 \pmod{7}$이다.
2. $p = 11, a = 3$일 때, $3^{11} \equiv 3 \pmod{11}$이다.

### 따름정리
<Bbox>

정수 $a$, 소수 $p$에 대하여, $a^{p-1} \equiv 1 \pmod{p}$이다.
또한, $a^{-1} = a^{p-2} \pmod{p}$이다.
</Bbox>

#### 증명
$a\times a \times a \times ... \times a \equiv a \times a \times a \times ... \times a \pmod{p}$이므로, <MathBox>$a^{p-1} \equiv 1 \pmod{p}$</MathBox>이다.
$a \times a^{-1} \equiv 1 \pmod{p}$이므로, <MathBox>$\mathbf{a^{-1} = a^{p-2} \pmod{p}}$</MathBox>이다.


## 오일러 정리 (Euler's Theorem)
<Bbox>

서로 소로수인 정수 $a$, 정수 $m$에 대하여, $a^{\phi(m)} \equiv 1 \pmod{m}$이다.
</Bbox>

#### 예시
$a = 5, m = 12$ 일 때, $\phi(12) = \phi(2^2 * 3^1) = (2^2 - 2^1) * (3^1 - 3^0) = 4$이다.
$\because (1, 5, 7, 11)$
따라서, $5^4 \equiv 1 \pmod{12}$이다.

## 중국인의 나머지 정리 (Chinese Remainder Theorem)
<Bbox>

p와 q가 서로소일 때, 두 방정식
$x ≡ a \pmod{p}$
$x ≡ b \pmod{p}$
은 pq에 대한 X의 유일한 해를 가진다.
</Bbox>

#### 증명
1. 존재성:

	$x = a \times q \times M_q + b \times p \times M_p \pmod{pq}$

	여기서 $M_q$는 $q^{-1} \pmod{p}$이고, $M_p$는 $p^{-1} \pmod{q}$이다.

2. 유일성:

	만약 $x ≡ y \pmod{p}$이고 $x ≡ y \pmod{q}$라면, $x - y$는 $p$와 $q$의 배수이다. 
	
	따라서, $x - y$는 $pq$의 배수이며 $x ≡ y \pmod{pq}$이다.

### 추가 설명

중국인의 나머지 정리는 두 개 이상의 서로소인 모듈러 산술 시스템에서 유일한 해를 찾는 데 사용된다. 이 정리는 여러 개의 다른 모듈로에 대해 서로 다른 나머지를 가지는 정수 x를 찾는 문제에 적용될 수 있다.

예를 들어, x가 3으로 나누었을 때는 2가 남고, 5로 나누었을 때는 3이 남는 숫자를 찾고 싶다고 가정하자. 이 경우에는 중국인의 나머지 정리를 사용하여 이러한 조건을 만족하는 유일한 x 값을 찾을 수 있다.

존재성 증명에서는 두 방정식을 만족하는 x의 구체적인 형태를 제공하고, 유일성 증명에서는 두 방정식을 만족하는 어떤 두 수도 서로 동등함을 보여준다. 이러한 원리는 컴퓨터 알고리즘 설계와 암호학에서 특정한 종류의 문제를 해결하기 위해 중요하게 사용된다. 예를 들어, 여러 개의 서로 다른 기준으로 정보를 분산시키고자 할 때 중국인의 나머지 정리를 통해 이 정보를 효과적으로 재조합할 수 있다.
#### 예시
$\mathbb{Z}_{105}$에서 $x ≡ 3 \pmod{7}$이고 $x ≡ 5 \pmod{15}$인 $x$를 찾으시오.

- $105 = 15 * 7$, $\gcd (15, 7) = 1$
- $p = 7, q = 15$로 둡니다.
- $M_q$는 $q^{-1} \pmod{p}$이고, 여기서는 $15^{-1} \pmod{7} = 1$입니다. (왜냐하면 15를 7로 나눈 나머지는 1이고 1의 역원은 1입니다.)
- $M_p$는 $p^{-1} \pmod{q}$이고, 여기서는 $7^{-1} \pmod{15} = 13$입니다. (왜냐하면 $7 * 13 = 91$은 15로 나눈 나머지가 1이기 때문입니다.)
- $x$는 $a * q * M_q + b * p * M_p$로 계산할 수 있으며, $x = 3 * 15 * 1 + 5 * 7 * 13 = 500$이고, 이를 105로 나눈 나머지는 80입니다.

#### 추가 설명

중국인의 나머지 정리를 활용한 이 예시는 두 개의 서로 다른 합동식을 만족하는 x의 값을 찾는 방법을 보여줍니다. 여기서 p와 q는 서로소이며, 각각의 합동식 $x ≡ 3 \pmod{7}$과 $x ≡ 5 \pmod{15}$에서 나머지를 각각 3과 5로 가집니다.

먼저, 주어진 mod p와 mod q에 대해 각각의 역원을 찾습니다. $M_q = 15^{-1} \pmod{7}$에서 15와 7은 서로소이므로 15의 7에 대한 모듈러 역원은 1입니다. $M_p = 7^{-1} \pmod{15}$에서도 마찬가지로 7의 15에 대한 모듈러 역원은 13입니다. 이 역원들을 사용하여 x 값을 계산합니다.

그 결과로 나온 x = 500을 주어진 105로 나눈 나머지는 80이므로, 이 값은 주어진 두 합동식을 모두 만족하는 유일한 해가 됩니다. 이렇게 중국인의 나머지 정리는 여러 개의 모듈러 산술 조건을 만족하는 해를 찾는 데 유용하게 쓰일 수 있습니다.



## (확률적) 소수 판정법: 페르마 검사 (Probabilistic Primality Test: Fermat Test)
- 정리 (페르마의 소정리)

	a를 정수, p를 소수라고 할 때,

	$a^p ≡ a (mod p) (\Longleftrightarrow a^{ p-1} ≡ 1 (mod p))$


**알고리즘 5 페르마 소수 판정법**
입력: 후보 $\bar{p}$와 보안 매개변수 λ
출력: "$\bar{p}$ 은 소수이다" 혹은 "$\bar{p}$은 합성수이다"
    
1: λ까지 i에 대해 반복한다.
2: 무작위로 ${2, 3, ..., \bar{p} - 2}$에서 a를 선택한다.
3: 만약 $a^{\bar{p}-1} ≡ 1 (mod \bar{p})$가 아니라면,
4: "$\bar{p}$은 합성수이다"를 반환한다.
5: 그 경우 종료한다.
6: 반복 종료 후,
7: "$\bar{p}$은 소수이다"를 반환한다.
    

#### 추가 설명

페르마의 소수 판정법은 주어진 수가 소수인지 합성수인지를 판별하는 확률적 알고리즘이다. 이 방법은 페르마의 소정리를 기반으로 하며, 어떤 수 $\bar{p}$가 소수일 가능성을 평가하기 위해 사용된다. 알고리즘은 보안 매개변수 λ만큼 많은 수의 무작위 테스트를 수행한다. 각 테스트에서, 2와 $\bar{p} - 2$ 사이의 무작위 수 a를 선택하고 $a^{\bar{p}-1}$을 계산한 후 이 결과가 $\bar{p}$에 대한 모듈로 1과 같은지 확인한다.

만약 $a^{\bar{p}-1} ≡ 1 (mod \bar{p})$이 성립하지 않는 경우가 하나라도 발견되면 $\bar{p}$는 합성수라는 것을 의미하고, 알고리즘은 "$\bar{p}$은 합성수이다"라고 결론지어 실행을 중단한다. 모든 테스트를 통과하면 $\bar{p}$은 높은 확률로 소수라고 할 수 있으며, "$\bar{p}$은 소수이다"라고 결론을 내린다.

이 방법은 확률적이기 때문에, 항상 100% 정확하다고 보장할 수는 없으나, λ를 적절히 크게 선택함으로써 오류의 확률을 매우 낮출 수 있다. 페르마의 소수 판정법은 계산이 비교적 간단하기 때문에 큰 수에 대한 소수 판별에 유용하게 사용될 수 있다.




## 반례: 카마이클 수	(Counterexample: Carmichael Number)

- 정의 (카마이클 수)
카마이클 수 C는 합성수이며 모든 a에 대해 $gcd(a, C) = 1$일 때 다음을 만족하는 수이다.
$a^{C-1} ≡ 1 (mod C)$
- 예시
• $N = 561 = 3 * 11 * 17$
• 모든 a에 대해 $gcd(a, 561) = 1$일 때, $a^{560} ≡ 1 (mod 561)$
• 페르마 검사는 카마이클 수를 소수로 판별한다.
• 대략 10^6 개의 카마이클 수가 10^15 이하에 존재한다.

#### 추가 설명

카마이클 수는 페르마의 소정리의 조건을 만족하는 특별한 종류의 합성수를 의미한다. 즉, $a^{C-1} ≡ 1 (mod C)$를 만족하지만 C 자체는 소수가 아닌 수를 말한다. 이러한 수는 페르마 검사에서 소수로 잘못 판별될 수 있는 '가짜 소수'의 한 예시이다.

카마이클 수는 페르마 검사 같은 소수 판별법에 대한 반례를 제공함으로써, 이러한 검사법들이 항상 완벽하게 정확하지는 않음을 보여준다. 예를 들어, 561과 같은 카마이클 수는 페르마 검사를 통과하지만 실제로는 3, 11, 17의 곱으로 이루어진 합성수이다.

카마이클 수는 상대적으로 드물기 때문에, 대부분의 수에 대해 페르마 검사는 여전히 유용하다. 그러나 카마이클 수의 존재는 소수 판별법을 설계할 때 주의를 기울여야 함을 상기시킨다. 따라서 더 정교한 소수 판별법, 예를 들어 밀러-라빈 검사와 같은 방법들이 카마이클 수에 대해서도 정확하게 소수를 판별할 수 있도록 개발되었다.



## (확률적) 소수 판정법 II: 밀러-라빈 검사 - 아이디어 (Probabilistic Primality Test II: Miller-Rabin Test - Idea)

- 정리

	$\bar{p} - 1 = 2^r * s$ 형태이고 s가 홀수일 때, 만약 어떤 정수 a에 대해

	$a^s \neq  1 (mod \bar{p})$이고 $a^{s*2^j} \neq \bar{p} - 1 (mod \bar{p})$가 모든 j에 대해 ${0, 1, ..., r - 1}$이면, 그러면 $\bar{p}$은 합성수이다. 

	그렇지 않다면, $\bar{p}$은 아마도 소수일 것이다.

- 예시
	- $\bar{p} = 561 = 3 * 11 * 17$
	- $\bar{p} - 1 = 560 = 2^4 * 35$

$5^35 ≡ 23 (mod 561)$
$5^(35*2) ≡ 529 (mod 561)$
$5^(35*2^2) ≡ 529^2 ≡ 463 (mod 561)$
$5^(35*2^3) ≡ 463^2 ≡ 67 (mod 561)$
$\Longrightarrow $ 561은 합성수이다!

#### 추가 설명

밀러-라빈 검사는 소수 판별법 중 하나로, 주어진 후보 $\bar{p}$이 소수인지 판별하는 데 사용되는 확률적 방법이다. 이 검사는 페르마 검사의 한계를 극복하기 위해 설계되었으며, 특히 카마이클 수와 같은 특별한 합성수에 대해서도 정확한 결과를 제공한다.

검사 방법은 다음과 같다: 주어진 후보 $\bar{p}$을 $\bar{p} - 1 = 2^r * s $형태로 표현한다. 이때, s는 홀수이다. 그런 다음, $a^s$를 계산하고 이 수가 1 또는 $\bar{p} - 1$과 다를 경우 $a^(s*2), a^(s*2^2), ..., a^{s*2^(r-1)}$의 계산을 이어간다. 이 수들 중 하나라도 $\bar{p} - 1$과 동일하다면, $\bar{p}$은 소수일 가능성이 높다. 그러나 이 모든 수가 $\bar{p}$ - 1과 다르다면 $\bar{p}$은 합성수이다.

이 예시에서는 561을 검사할 때 5를 기반으로 한 검사를 수행한다. $5^35, 5^(35*2), ..., 5^{35*2^3}$를 계산하고 이 결과가 모두 561 - 1, 즉 560과 다르기 때문에 561은 합성수임이 밝혀졌다. 밀러-라빈 검사는 이러한 방법으로 소수 판별의 정확도를 높이는 데 큰 도움을 준다.

## 밀러-라빈 소수 판정법 설명

- 알고리즘 6 밀러-라빈 소수 판정법
입력: 후보 $\bar{p}$와 $\bar{p} - 1 = 2^r * s$ 형태의 s는 홀수, 보안 매개변수 λ
출력: "$\bar{p}$은 소수이다" 혹은 "$\bar{p}$은 합성수이다"
    
1: λ까지 i에 대해 반복한다.
2: ${2, 3, ..., \bar{p} - 2}$에서 무작위로 a를 선택한다.
3: z에 $a^s (mod \bar{p})$를 계산하여 할당한다.
4: 만약 $z \neq 1$이고 $z \neq \bar{p} - 1$이면,
5: $r - 1$까지 j에 대해 반복한다.
6: z에 $z^2 (mod \bar{p})$을 계산하여 할당한다.
7: 만약 $z = 1$이면,
8: "$\bar{p}$은 합성수이다"를 반환하고 종료한다.
9: 그 경우 종료한다.
10: $j$에 대한 반복을 종료한다.
11: 만약 $z \neq \bar{p} - 1$이면,
12: "$\bar{p}$은 합성수이다"를 반환하고 종료한다.
13: 그 경우 종료한다.
14: i에 대한 반복을 종료한다.
15: "$\bar{p}$은 소수이다"를 반환한다.
    

### 추가 설명

밀러-라빈 소수 판정법은 확률적 알고리즘으로, 정해진 횟수 λ만큼 반복하여 주어진 수 p̃가 소수일 가능성을 테스트한다. 각 반복마다, 무작위로 선택된 a에 대해 몇 가지 계산을 수행하여 p̃가 소수인지를 판별한다.

이 알고리즘은 $p̃ - 1 = 2^r * s$와 같이 표현될 때 s가 홀수인 경우에 작동한다. 먼저, $a^s (mod p̃)$를 계산하고, 그 결과가 1 또는 p̃ - 1이 아니면 $z^2$를 반복적으로 계산한다. 이 과정에서 z가 1로 돌아오면 p̃는 합성수임이 확실하다. 만약 $z^2$를 r - 1번 계산하는 동안 p̃ - 1이 나타나지 않는다면, p̃는 합성수이다. 이 모든 테스트를 통과하면 p̃은 소수일 가능성이 높다.

밀러-라빈 검사는 페르마의 소수 판정법보다 더 정확하며, 특히 카마이클 수와 같은 특별한 합성수들을 걸러낼 수 있는 장점이 있다. 그러나 이 방법도 확률적이기 때문에 소수 판정에 대한 절대적인 확신을 줄 수는 없다. 하지만, 보안 매개변수 λ를 크게 설정함으로써, 오류 확률을 충분히 낮출 수 있다.



# RSA Encryption (RSA 암호화)
## RSA 암호화 개요 (Overview of RSA Encryption)
RSA 암호화는 공개키 암호화 방식 중 하나로, 1977년에 MIT의 Ronald Rivest, Adi Shamir, Leonard Adleman에 의해 개발되었습니다. 
RSA는 각자의 이니셜을 따서 명명되었으며, 이는 공개키 암호화 방식 중 가장 널리 사용되는 방식 중 하나입니다.
RSA 암호화는 공개키와 개인키를 사용하여 암호화와 복호화를 수행합니다. 
공개키는 누구나 알 수 있지만, 개인키는 암호화를 수행한 사람만 알 수 있습니다. 
이러한 특성으로 RSA 암호화는 안전한 통신을 위해 사용됩니다.

## RSA: 키 생성 (RSA: Key Generation)
1. 두 개의 소수를 선택합니다. 이 두 소수를 p와 q라고 한다.
2. $N = p * q$를 계산합니다. n은 모듈러스(modulus)로 사용된다.
3. $\phi(n) = (p-1) * (q-1)$를 계산합니다. $\phi(n)$은 n과 서로소인 수의 개수를 의미함
4. $e$를 선택합니다. $1 < e < \phi(n)$이며, $e$와 $\phi(n)$은 서로소여야 함.
5. $d$를 계산합니다. $d$는 $d * e \equiv 1 \pmod{\phi(n)}$을 만족하는 수이다.
6. 공개키$pk$는 $(n, e)$이며, 개인키$sk$는 $d$이다.

## RSA: 암호화 & 복호화 (RSA: Encryption & Decryption)
