## 3.1 Transport-layer services

### 전송 서비스와 프로토콜 _Transport services and protocols_

전송 서비스와 프로토콜은 서로 다른 호스트에서 실행 중인 응용 프로그램 프로세스 간에 논리적인 종단 간 통신을 제공한다.<br/>
전송 계층이 네트워크 계층을 '사용'하여 종단 간 통신 제공<br/>
전송 프로토콜은 종단 시스템에서 실행됨
- 보내는 쪽: 응용 프로그램 메시지를 세그먼트로 나누고 네트워크 계층으로 전달
- 받는 쪽: 세그먼트를 메시지로 재조립하고 응용 프로그램 계층으로 전달
하나 이상의 전송 프로토콜이 앱에 사용될 수 있다.<br/>
- ex) 인터넷에서 : UDP, TCP

### 전송계층 VS 네트워크 계층 _Transport VS Network layer_

**네트워크 계층**: 호스트 간의 논리적 통신<br/>
**전송 계층**: 프로세스 간의 논리적 통신->네트워크 계층에 의존, 강화시킴<br/>
	

### 인터넷 전송계층 프로토콜 _Internet Transport-Layer Protocols_

**TCP** : 신뢰할 수 있는 순차적인 전송 서비스 제공<br/>
- 연결 설정, 신뢰할 수 있는 데이터 전송, 혼잡 제어, 흐름 제어<br/>

**UDP** : 비신뢰적인 서비스 제공, 신뢰성이 필요 없는 앱에 사용<br/>
- 연결 설정 없음, 신뢰성 없음, 흐름 제어 없음

## 3.2 Multiplexing and demultiplexing

### 멀티플렉싱/디멀티플렉싱  _Multiplexing and demultiplexing_

**멀티플렉싱**: 여러 프로세스가 전송 계층에 데이터를 보낼 때, 전송 계층은 이 데이터를 받아서 네트워크 계층에 전달<br/>
**디멀티플렉싱**: 네트워크 계층이 받은 데이터를 전송 계층에 전달<br/>

호스트 간의 배달 서비스를 호스트에서 실행되는 응용 프로그램에 대한 프로세스 간 배달 서비스로 확장


송신자 입장: 다중 소켓에서 데이터 처리, 전송 헤더 추가<br/>
수신자 입장: 헤더 정보를 사용하여 수신된 세그먼트를 올바른 소켓으로 전달<br/>
--> 이 헤더에는 보통 송수신자의 포트 번호가 포함되어 있으며, 이는 네트워크 상에서의 프로세스를 구별하는 데 중요한 역할을 한다.

### 인터넷에서의 패킷 캡슐화/디캡슐화 _Packet encapsulation/decapsulation in the Internet_

##### 캡슐화: 데이터를 전송하기 위해 헤더를 추가하는 과정<br/>
Application message -> TCP 헤더 추가 -> IP 헤더 추가 -> Ethernet(link) 헤더 추가 -> 전송<br/>


##### 디캡슐레이션: 데이터를 받아서 헤더를 제거하는 과정<br/>
Ethernet(link) 헤더 제거 -> IP 헤더 제거 -> TCP 헤더 제거 -> Application message 전달<br/>

### 디멀티플렉싱 작동방법  _How demultiplexing works_
##### 디멀티플렉싱: 호스트가 IP 데이터그램을 수신할 때 이루어지는 과정
- IP 데이터그램: 목적지 IP 주소와 목적지 포트 번호를 포함
- 목적지 IP 주소: 호스트의 IP 주소
- 목적지 포트 번호: 수신자 프로세스의 소켓 번호

수신 호스트가 세그먼트를 받으면 네트워크 계층은 IP 주소 확인, 전송 계층은 포트 번호 확인<br/>

### 연결 지향 vs 비연결 지향 _Connectionless vs Connection-oriented demux_

##### UDP : 비연결 지향
- 소켓이 호스트-로컬 포트 번호를 가지고 있지만 목적지 포트 번호는 없음
- 수신 호스트는 IP 주소와 목적지 포트 번호를 사용하여 세그먼트를 디멀티플렉싱

##### TCP : 연결 지향
- 소켓이 호스트-로컬 포트 번호와 목적지 포트 번호를 가지고 있음
- 소켓은 4-튜플로 식별됨 : (소스 IP 주소, 소스 포트 번호, 목적지 IP 주소, 목적지 포트 번호)
#### 예시
![240423-145950](/posts/content/240423-145950.png)
![240423-150114](/posts/content/240423-150114.png)

## 3.3 Connectionless transport: UDP

### UDP 서비스 _UDP services_

#### UDP 서비스를 사용하는 이유
- 간단하고 빠름
- 연결 설정이 필요 없음
- 신뢰성이 필요 없는 앱에 사용
- 흐름 제어, 혼잡 제어가 필요 없음
- 작은 헤더 크기

#### UDP 단점
- 신뢰성이 없음
- 순서가 보장되지 않음
- 흐름 제어, 혼잡 제어가 없음
- 데이터그램이 손실될 수 있음
- 데이터그램이 중복될 수 있음
- 데이터를 잃어버릴 시 UDP는 알지 못함

### 비트탐지 _checksum_

송신자: 세그먼트의 내용 처리, 체크섬 계산, 체크섬을 세그먼트에 추가<br/>
수신자: 세그먼트의 내용 처리, 체크섬 계산, 송신자가 계산한 체크섬과 비교<br/>
![240423-151424](/posts/content/240423-151424.png)

## 3.4 principles of reliable data transfer
### 신뢰성 있는 데이터 전송의 원리 _Principles of reliable data transfer_
- 상위 계층은 하위 계층 채널을 '사용'한다.
### RDT 1.0
**특징**: 가장 기본적인 버전으로, 오류가 발생하지 않는 채널에서만 작동합니다.<br/>
**동작 원리**: 송신자가 데이터 패킷을 보내고, 수신자가 패킷을 받으면 확인 응답(ACK)을 보냅니다. 네트워크에 오류가 전혀 없다고 가정하기 때문에 재전송이나 오류 검사 메커니즘이 없습니다.
### RDT 2.0
**특징**: 오류가 발생할 수 있는 채널에서 사용할 수 있도록 설계되었습니다.<br/>
**동작 원리**: 패킷에 체크섬을 추가하여 송신자가 데이터를 보낼 때 오류 검사가 가능합니다. 수신자는 체크섬을 통해 패킷의 정확성을 검사하고, 오류가 있을 경우 음수 응답(NACK)을 보내 재전송을 요청합니다.
### RDT 2.1
**특징**: 오류와 패킷 손실에 대응하기 위해 추가적인 기능이 포함되었습니다.<br/>
**동작 원리**: 송신자는 패킷을 보내고 타이머를 설정합니다. ACK나 NACK 응답을 받지 못하면 타이머가 만료되고 패킷을 재전송합니다.
### RDT 2.2
**특징**: NACK 응답 대신 오직 ACK만을 사용하여 통신의 효율성을 개선합니다.<br/>
**동작 원리**: 수신자는 오류가 있는 패킷을 받으면 최근에 올바르게 받은 패킷의 ACK를 재전송합니다. 이를 통해 송신자는 어떤 패킷이 문제인지 알 수 있고 해당 패킷만 재전송합니다.
### RDT 3.0
**특징**: 패킷 손실과 오류, 그리고 순서가 바뀐 문제들을 처리할 수 있습니다.<br/>
**동작 원리**: 송신자는 각 패킷에 시퀀스 번호를 부여하고, 수신자는 시퀀스 번호를 검사하여 순서대로 패킷을 재조합합니다. ACK나 패킷의 재전송도 시퀀스 번호를 기반으로 처리됩니다.