# 데이터 입,출력 구현 - 자료구조, 알고리즘
## 자료구조의 분류
- 선형구조 (Linear Structure)
	- 배열 (Array)
	- 선형 리스트 (Linear List)
		- 연속 리스트 (Contiguous List)
		- 연결 리스트 (Linked List)
	- 스택 (Stack)
	- 큐 (Queue)
	- 데크 (Deque)
- 비선형구조 (Non-Linear Structure)
	- 트리 (Tree)
	- 그래프 (Graph)

## 선형 구조 (Linear Structure)
### 선형 리스트 (Linear List)
연속 리스트
- 연속 리스트는 배열과 같이 연속되는 메모리 공간에 데이터를 저장하는 자료구조이다.
- 데이터의 삽입, 삭제 연산시 자료의 이동이 필요하다
- 메모리 효율이 좋다
연결 리스트
- 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료이다
- 데이터의 삽입, 삭제 연산시 자료의 이동이 필요없다
- 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다

### 스택 (Stack)
> 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조

- 후입선출 (Last In First Out, LIFO) 구조
- 응용 분야
	- 함수 호출 순서 제어
	- 인터럽트 처리
	- 수식 계산 및 수식 표기법
	- 컴파일러를 이용한 언어 번역
	- 서브루틴 호출 및 복귀 주소 저장
모든 공간이 채워져 있는 상태에서 삽입 연산을 수행하면 *스택 오버플로우*가 발생한다
모든 공간이 비워져 있는 상태에서 삭제 연산을 수행하면 *스택 언더플로우*가 발생한다
![240507-143507w](/posts/240507-143507.png)
[이미지 출처](https://www.geeksforgeeks.org/stack-data-structure/)

### 큐 (Queue)
> 리스트의 한쪽에서 삽입 작업이 이루어지고 다른 한쪽에서 삭제 작업이 이루어지는 자료 구조

- 선입선출 (First In First Out, FIFO) 구조
- 시작과 끝을 나타내는 두 개의 포인터가 존재
![240507-143759w](/posts/240507-143759.png)
[이미지 출처](https://www.geeksforgeeks.org/queue-data-structure/)


## 비선형 구조 (Non-Linear Structure)
### 방향/무방향 그래프의 최대 간선 수
- 방향 그래프의 최대 간선 수: n(n-1)
- 무방향 그래프의 최대 간선 수: n(n-1)/2
### 트리의 개요
트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태
- 루트(Root): 트리의 시작 정점
- 부모(Parent): 노드에서 가리키는 상위 노드
- 자식(Child): 노드를 가리키는 하위 노드
- 형제(Sibling): 같은 부모를 가지는 노드
- 차수(Degree): 노드에 연결된 자식의 수
- 레벨(Level): 루트로부터의 깊이
- 높이(Height): 트리의 최대 레벨

### 트리의 운행법
- 전위 운행법 (Preorder Traversal)
	- 루트 -> 왼쪽 자식 -> 오른쪽 자식
- 중위 운행법 (Inorder Traversal)
	- 왼쪽 자식 -> 루트 -> 오른쪽 자식
- 후위 운행법 (Postorder Traversal)
	- 왼쪽 자식 -> 오른쪽 자식 -> 루트

#### 수식 표기법
- 전위 표기법 (Prefix Notation)
	- 연산자를 먼저 표기
	- +AB
- 중위 표기법 (Infix Notation)
	- 연산자를 중간에 표기
	- A+B
- 후위 표기법 (Postfix Notation)
	- 연산자를 나중에 표기
	- AB+

## 정렬
### 삽입 정렬 (Insertion Sort)
> 삽입 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 정렬된 부분에 삽입하는 방식으로 정렬하는 알고리즘이다

![240507-144655w](/posts/240507-144655.png)
[이미지 출처](https://dev.to/harshanalk/data-sorting-1k86)

### 선택 정렬 (Selection Sort)
> 선택 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분에서 가장 작은 원소를 선택하여 정렬된 부분의 마지막 원소와 교환하는 방식으로 정렬하는 알고리즘이다

![240507-144635](/posts/240507-144635.png)
[이미지 출처](https://dev.to/harshanalk/data-sorting-1k86)

### 버블 정렬 (Bubble Sort)
> 버블 정렬은 인접한 두 원소를 비교하여 정렬하는 방식으로 정렬하는 알고리즘이다

### 퀵 정렬 (Quick Sort)
> 퀵 정렬은 분할 정복 방법을 사용하여 배열을 정렬하는 알고리즘이다

하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 이동시킨다
평군 수행 시간 복잡도는 `O(n log n)`이다
최악의 경우 수행 시간 복잡도는 `O(n^2)`이다
![240507-144832](/posts/240507-144832.png)
[이미지 출처](https://dev.to/harshanalk/data-sorting-1k86)

### 힙 정렬 (Heap Sort)
> 힙 정렬은 힙 자료구조를 이용하여 정렬하는 알고리즘이다

### 2-Way 합병 정렬 (Merge Sort)
> 2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다

평균과 최악의 경우 수행 시간 복잡도는 `O(n log n)`이다

![240507-144930](/posts/240507-144930.png)
[이미지 출처](https://www.upgrad.com/blog/sorting-in-data-structure-with-examples/)

## 검색 알고리즘 (Search Algorithm)
### 이분 검색 (Binary Search)
> 이분 검색은 정렬된 배열에서 중간 값을 기준으로 검색하는 방식으로 검색하는 알고리즘이다

전체 파일을 두 개의 서브파일로 분리해 가면서 Key 리코드를 검색하는 방식
- 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어듦으로 탐색 효율이 좋고 탐색 시간이 적게 소요됨
- 중간 레코드 번호 $M=(F+L)/2$로 계산
	- F: 검색 대상의 첫 번째 레코드 번호, L: 검색 대상의 마지막 레코드 번호

### 해싱 함수 (Hashing Function)
> 해싱 함수는 키를 해시 테이블의 주소로 변환하는 함수이다

- **제산법(Division)**: 레코드 키(K)를 해시표(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나는 나머지를 홈 주소로 삼는 방식
	- $H(K) = K \mod M$
- **제곱법(Mid-Square)**: 레코드 키(K)를 제곱한 후, 그 결과의 중간 부분을 홈 주소로 삼는 방식
	- $H(K) = (K^2) \mod M$
- **폴딩법(Folding)**: 레코드 키(K)를 여러 부분으로 나눈 후, 이를 더한 값을 홈 주소로 삼는 방식
	- $H(K) = (K_1 + K_2 + K_3 + \cdots + K_n) \mod M$
- **기수 변환법(Radix)**: 레코드 키(K)를 해시 테이블의 크기(M)에 대한 진수로 변환한 후, 이를 홈 주소로 삼는 방식
	- $H(K) = K_{10} \mod M$
- **대수적 코딩법(Algebraic Coding)**: 레코드 키(K)를 다항식으로 변환한 후, 이를 홈 주소로 삼는 방식
	- $H(K) = aK^2 + bK + c$
- **숫자 분석법(Digit Analysis, 계수 분석법)**: 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 추출하여 홈 주소로 삼는 방식
- **무작위법(Random)**: 레코드 키(K)를 무작위로 선택하여 홈 주소로 삼는 방식

# 
## DBMS의 개요
