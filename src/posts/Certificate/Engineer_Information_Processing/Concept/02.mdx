## 자료구조의 분류
- 선형구조 (Linear Structure)
	- 배열 (Array)
	- 선형 리스트 (Linear List)
		- 연속 리스트 (Contiguous List)
		- 연결 리스트 (Linked List)
	- 스택 (Stack)
	- 큐 (Queue)
	- 데크 (Deque)
- 비선형구조 (Non-Linear Structure)
	- 트리 (Tree)
	- 그래프 (Graph)

## 선형 구조 (Linear Structure)
### 선형 리스트 (Linear List)
연속 리스트
- 연속 리스트는 배열과 같이 연속되는 메모리 공간에 데이터를 저장하는 자료구조이다.
- 데이터의 삽입, 삭제 연산시 자료의 이동이 필요하다
- 메모리 효율이 좋다
연결 리스트
- 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료이다
- 데이터의 삽입, 삭제 연산시 자료의 이동이 필요없다
- 연결을 위한 포인터를 찾는 시간이 필요하기 때문에 접근 속도가 느리다

### 스택 (Stack)
> 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조

- 후입선출 (Last In First Out, LIFO) 구조
- 응용 분야
	- 함수 호출 순서 제어
	- 인터럽트 처리
	- 수식 계산 및 수식 표기법
	- 컴파일러를 이용한 언어 번역
	- 서브루틴 호출 및 복귀 주소 저장
모든 공간이 채워져 있는 상태에서 삽입 연산을 수행하면 *스택 오버플로우*가 발생한다
모든 공간이 비워져 있는 상태에서 삭제 연산을 수행하면 *스택 언더플로우*가 발생한다
![240507-143507w](/posts/240507-143507.png)
[이미지 출처](https://www.geeksforgeeks.org/stack-data-structure/)

### 큐 (Queue)
> 리스트의 한쪽에서 삽입 작업이 이루어지고 다른 한쪽에서 삭제 작업이 이루어지는 자료 구조

- 선입선출 (First In First Out, FIFO) 구조
- 시작과 끝을 나타내는 두 개의 포인터가 존재
![240507-143759w](/posts/240507-143759.png)
[이미지 출처](https://www.geeksforgeeks.org/queue-data-structure/)


## 비선형 구조 (Non-Linear Structure)
### 방향/무방향 그래프의 최대 간선 수
- 방향 그래프의 최대 간선 수: n(n-1)
- 무방향 그래프의 최대 간선 수: n(n-1)/2
### 트리의 개요
트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태
- 루트(Root): 트리의 시작 정점
- 부모(Parent): 노드에서 가리키는 상위 노드
- 자식(Child): 노드를 가리키는 하위 노드
- 형제(Sibling): 같은 부모를 가지는 노드
- 차수(Degree): 노드에 연결된 자식의 수
- 레벨(Level): 루트로부터의 깊이
- 높이(Height): 트리의 최대 레벨

### 트리의 운행법
- 전위 운행법 (Preorder Traversal)
	- 루트 -> 왼쪽 자식 -> 오른쪽 자식
- 중위 운행법 (Inorder Traversal)
	- 왼쪽 자식 -> 루트 -> 오른쪽 자식
- 후위 운행법 (Postorder Traversal)
	- 왼쪽 자식 -> 오른쪽 자식 -> 루트

#### 수식 표기법
- 전위 표기법 (Prefix Notation)
	- 연산자를 먼저 표기
	- +AB
- 중위 표기법 (Infix Notation)
	- 연산자를 중간에 표기
	- A+B
- 후위 표기법 (Postfix Notation)
	- 연산자를 나중에 표기
	- AB+

## 정렬
### 삽입 정렬 (Insertion Sort)
> 삽입 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분의 원소를 정렬된 부분에 삽입하는 방식으로 정렬하는 알고리즘이다

![240507-144655w](/posts/240507-144655.png)
[이미지 출처](https://dev.to/harshanalk/data-sorting-1k86)

### 선택 정렬 (Selection Sort)
> 선택 정렬은 배열을 정렬된 부분과 정렬되지 않은 부분으로 나누고, 정렬되지 않은 부분에서 가장 작은 원소를 선택하여 정렬된 부분의 마지막 원소와 교환하는 방식으로 정렬하는 알고리즘이다

![240507-144635](/posts/240507-144635.png)
[이미지 출처](https://dev.to/harshanalk/data-sorting-1k86)

### 버블 정렬 (Bubble Sort)
> 버블 정렬은 인접한 두 원소를 비교하여 정렬하는 방식으로 정렬하는 알고리즘이다

### 퀵 정렬 (Quick Sort)
> 퀵 정렬은 분할 정복 방법을 사용하여 배열을 정렬하는 알고리즘이다

하나의 파일을 부분적으로 나누어 가면서 정렬하는 방법으로 키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 이동시킨다
평군 수행 시간 복잡도는 `O(n log n)`이다
최악의 경우 수행 시간 복잡도는 `O(n^2)`이다
![240507-144832](/posts/240507-144832.png)
[이미지 출처](https://dev.to/harshanalk/data-sorting-1k86)

### 힙 정렬 (Heap Sort)
> 힙 정렬은 힙 자료구조를 이용하여 정렬하는 알고리즘이다

### 2-Way 합병 정렬 (Merge Sort)
> 2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식이다

평균과 최악의 경우 수행 시간 복잡도는 `O(n log n)`이다

![240507-144930](/posts/240507-144930.png)
[이미지 출처](https://www.upgrad.com/blog/sorting-in-data-structure-with-examples/)

## 검색 알고리즘 (Search Algorithm)
### 이분 검색 (Binary Search)
> 이분 검색은 정렬된 배열에서 중간 값을 기준으로 검색하는 방식으로 검색하는 알고리즘이다

전체 파일을 두 개의 서브파일로 분리해 가면서 Key 리코드를 검색하는 방식
- 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어듦으로 탐색 효율이 좋고 탐색 시간이 적게 소요됨
- 중간 레코드 번호 $M=(F+L)/2$로 계산
	- F: 검색 대상의 첫 번째 레코드 번호, L: 검색 대상의 마지막 레코드 번호

### 해싱 함수 (Hashing Function)
> 해싱 함수는 키를 해시 테이블의 주소로 변환하는 함수이다

- **제산법(Division)**: 레코드 키(K)를 해시표(Hash Table)의 크기보다 큰 수 중에서 가장 작은 소수(Prime, Q)로 나는 나머지를 홈 주소로 삼는 방식
	- $H(K) = K \mod M$
- **제곱법(Mid-Square)**: 레코드 키(K)를 제곱한 후, 그 결과의 중간 부분을 홈 주소로 삼는 방식
	- $H(K) = (K^2) \mod M$
- **폴딩법(Folding)**: 레코드 키(K)를 여러 부분으로 나눈 후, 이를 더한 값을 홈 주소로 삼는 방식
	- $H(K) = (K_1 + K_2 + K_3 + \cdots + K_n) \mod M$
- **기수 변환법(Radix)**: 레코드 키(K)를 해시 테이블의 크기(M)에 대한 진수로 변환한 후, 이를 홈 주소로 삼는 방식
	- $H(K) = K_{10} \mod M$
- **대수적 코딩법(Algebraic Coding)**: 레코드 키(K)를 다항식으로 변환한 후, 이를 홈 주소로 삼는 방식
	- $H(K) = aK^2 + bK + c$
- **숫자 분석법(Digit Analysis, 계수 분석법)**: 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 추출하여 홈 주소로 삼는 방식
- **무작위법(Random)**: 레코드 키(K)를 무작위로 선택하여 홈 주소로 삼는 방식

## 빌드 자동화 도구
> 소스 코드를 소프트웨어로 변환하는 과정에 필요한 전처리, 컴파일 등의 작업 수행

| 도구 | 설명 |
|---|---|
| **Ant(Another Neat Tool)** | 자바 프로젝트의 공식적 빌드 자동화 도구(XML 기반)<br/>표준이 없어 개발자가 모든 것을 정의함, 스크립트 재사용 어려움 |
| **Maven** | 예외 사항만을 기록하는 표준이 있음(Ant의 대안)<br/>컴파일과 빌드 동시 수행 가능, 의존성 설정 후 라이브러리 관리 |
| **Gradle** | Groovy 스크립트를 사용하는 빌드 도구<br/>의존성을 활용하며 빌드 캐시 기능 지원 -> 속도 향상<br/>실행할 명령을 모아 태스크로 만든 후 태스크 단위 실행 |
| **Jenkins** | JAVA 기반 오픈소스 빌드 자동화 도구<br/>서블릿 컨테이너에서 실행<br/>형상 도구 관리와 연동 가능(Git, SVN) |

## 디지털 저작권 관리 (DRM, Digital Rights Management)
> 디지털 저작물의 저작권을 보호하고 관리하는 기술

- 콘텐츠 제공자/분배자/소비자/패키저(배포 가능한 암호화)
- *클리어링 하우스*(Clearing House) : 사용 권한, 라이선스 발급, 결제 관리
- *DRM 컨트롤러*: 배포된 콘텐츠의 이용 권한 통제
- *보안 컨테이너*: 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치
-> 기술 요소: 암호화/키 관리/식별 기술/저작권 표현/암호화 파일 생성/정책 관리/크랙 방지/인증

## 소프트웨어 형상 관리 (Software Configuration Management, SCM)
> 소프트웨어 개발 과정에서 발생하는 변경 사항을 체계적으로 관리하는 활동 -> 개발 전체 단계 적용

- 중요성: 변겨사항 추적/통제, 무절제한 변경 방지, 개발 진행 이력 확인
- 형상 관리 역할: 배포본 관리 용이, 불필요한 소스 수정 제한, 여러 개발자 동시 개발

| 단계 | 활동 |
|---|---|
| **형상 식별** | 관리 대상에 이름/번호 부여 후 계층 구조로 구분 → 수정/추적 용이 |
| **형상 제어** | 식별된 형상 항목에 대한 변경 요구 검토(기준선 반영) |
| **형상 감사** | 기준선(Base Line)의 무결성 평가를 위해 확인/검증/검열 과정 진행 |
| **형상 기록** | 형상 식별/통제/감사 작업 결과를 기록/관리하고 보고서 작성 |
- 형상 관리 도구: CVS, SVN, Git
- 제품 SW의 형상 관리 역할: 배포본 관리 유용/ 소스 수정 제한, 동일 프로젝트에 대해 여러 개발자 참여 후 동시 개발 가능

## 소프트웨어 버전 등록 용어
| 용어 | 설명 |
|---|---|
| **저장소(Repository)** | 최신 버전 및 변경 내역 관련 정보 저장소 |
| **가져오기(Import)** | 버전 관리 미진행 상태의 초기 저장소에 처음으로 파일을 복사 |
| **체크아웃(Checkout)** | 프로그램 수정을 위해 저장소에서 파일을 받아옴 |
| **체크인(Checkin)** | 체크아웃한 파일 수정 후 저장소에 새로운 버전으로 파일 갱신 |
| **커밋(Commit)** | 체크인 시 이전 갱신된 내용이 있는 경우 conflict를 알린 후 Diff 도구를 이용해 수정 후 갱신 완료 |
| **동기화(Update)** | 저장소의 변경 사항을 로컬에 반영하는 작업 |

## 소프트웨어 버전 관리 도구
| 도구 | 설명 |
|---|---|
| **공유폴더** | 파일 공유를 통한 로컬에서의 버전 관리<br/>ex) SCCS, *RCS*(Revision Control System), PVCS, QVCS |
| **클라이언트/서버** | 중앙 서버에 저장소를 두고 클라이언트가 서버에 접속해 파일 관리<br/>ex) CVS, *SVN*(Subversion), Perforce, ClearCase |
| **분산 저장소** | 로컬 저장소를 갖고 중앙 서버와 연결해 파일 관리<br/>ex) *Git*, Mercurial, Bazaar |
| **SVN(Subversion)** | CVS의 개선 버전<br/>커밋 할 때마다 리비전 1씩 증가<br/>CVS의 한계인 *파일이나 디렉터리의 이름 변경, 이동 가능* |
| **Git** | 원격 저장소: 여러 사람들이 협업을 위해 버전을 공동 관리하는 장소<br/>로컬 저장소: 개발자들이 본인의 실제 개발을 진행하는 장소<br/>브랜치 이용 시 기존 버전 관리 틀에 영향없이 다양한 기능 테스트 가능, 파일의 변화를 SnapShot으로 저장 |

## 소스 코드 품질분석 도구
- 정적 분석 도구: pmd(코드 결함), cppcheck(C/C++), checkstyle(Java), SonarQube, FindBugs, corbertura, ccm
- 동적 분석 도구: Valance, Valgrind, Avalanche

## EAI (Enterprise Application Integration)
> 기업 내 각종 앱/플랫폼 간 정보 전달/연계/통합 등 상호작용 연동하는 모듈 연계 방식

| 방식 | 설명 |
|---|---|
| **포인트-투-포인트(Point-to-Point)** | 데이터 간 포인트-포인트 개별 연결 → 변경 및 재사용 어려움 |
| **허브&스포크(Hub&Spoke)** | 중앙 집중식 허브를 통해 각 시스템 연결 → 확장/유지보수에 유리하나, 중앙 허브 장애 발생 시 전체 시스템에 영향 |
| **메시지 버스(Message Bus)** | 앱 사이에 미들웨어를 두고 처리/확장성 및 대용량 처리 가능 |
| **Hybrid** | 허브-스포크, 메시지 버스 방식 혼합 → 데이터 병목 현상 최소 |

## 어플리케이션 테스트 기본 원리
- 테스트는 기본적으로 결함이 존재함을 밝히는 것(결함이 없다고 증명하는 것은 불가)
- 결함 집중: *파레토*(Pareto) 법칙에 따라 80\% 결함은 20\% 모듈에 존재
- *살충제 패러독스*: 동일한 테스트 케이스에 의한 반복 테스트는 새로운 버그 발견 X
- 오류-부재의 궤변: 결함이 없다 해도 요구사항 미충족시 품질 저하
- Brooks의 법칙: 지연되는 프로젝트에 인력 추가 투입 시 더 지연됨

## 어플리케이션 테스트 분류
1. 프로그램 실행 여부
	| 분류 | 설명 |
	|---|---|
	| **정적 테스트(Static Test)** | 소스 코드 분석을 통해 테스트<br/>ex) 워크 스루, 인스펙션, 코드 검사 |
	| **동적 테스트(Dynamic Test)** | 프로그램 실행을 통해 테스트<br/>ex) 화이트/블랙박스 테스트 |
2. 테스트 기반
	| 분류 | 설명 |
	|---|---|
	| **명세 기반** | 사용자의 요구사항 명세서를 기반으로 테스트<br/>ex)동등 분할/경계값 분석(블랙박스)|
	| **구조 기반** | 소프트웨어 구조를 기반으로 테스트<br/>ex)구문 기반/결정 기반/조건 기반(화이트박스)|
	| **경험 기반** | 테스터의 경험을 기반으로 테스트<br/>ex)에러 추정, 체크리스트, 탐색적 테스팅 |	
3. 시각(관점) 기반
	| 분류 | 설명 |
	|---|---|
	| **검증(Validation)** | *개발자*의 시각에서 제품의 생산성 과정 테스트<br/>ex)단위/통합/시스템 테스트 |
	| **확인(Verification)** | *사용자*의 시각에서 생산된 제품의 결과 테스트<br/>ex)인수 테스트 (알파/베타) |
4. 목적 기반
	| 분류 | 설명 |
	|---|---|
	| **회복(Recovery)** | 시스템에 인위적 결함 부여 후 정상으로 회복되는 과정 확인 |
	| **안전(Security)** | 외부 불법 침입으로부터 시스템을 보호할 수 있는지 확인 |
	| **강도(Stress)** | 과부하 시 SW 정상 구동 여부 확인 |
	| **성능(Performance)** | 실시간 성능 및 전체적인 효율성 진단(응답시간, 업무 처리량) |
	| **구조(Structural)** | SW 내부 논리적 경로 및 소스 코드 복잡도 평가 |
	| **회귀(Regression)** | SW 내 변경 또는 수정된 코드에 새로운 결함이 없음을 확인 |
	| **병행(Concurrent)** | 변경 및 기존 SW에 동일한 데이터 입력 후 결과 비교 |

## 화이트박스 테스트 (White Box Test)
- 모듈 안의 내용(작동) 직접 볼 수 있으며, 내부의 논리적인 *모든 경로 테스트*
- 소스 코드의 모든 문장을 한 번 이상 수행/ *논리적 경로 점검* (선택,반복 수행)
- 테스트 데이터 선택을 위해 *검증 기준*(Coverage)을 정함
	→ *기초 경로 검사*(Base Path Test): 대표적 화이트박스 테스트 기법(동적 테스트) / 싸이클 최대 한번
	→ 제어 구조 검사(Control Structure Test): *조건 검사*, *루프 검사*, *자료 흐름 검사*

## 블랙박스 테스트 (Black Box Test)
- 모듈 내부의 내용 알 수 없음 / 소프트웨어 인터페이스에서 실시되는 테스트
- SW 각 기능이 완전히 작동되는 것을 입증하는 테스트로 *기능 테스트*라고 함
	→ **동치 분할 검사/ 경계값 분석/ 원인-효과 그래프 검사/ 비교 검사/ 오류 예측 검사**

## 개발 단계에 따른 어플리케이션 테스트
1. **단위 테스트(Unit Test)**
	- 개별 모듈(컴포넌트)이 정상적으로 작동하는지 확인
	- 주로 *구조 기반 테스트* 진행 / 기능성 테스트 최우선
2. **통합 테스트(Integration Test)**
	- 단위 테스트 후 모듈을 통합하는 과정에서 발생하는 오류 확인
	- *상향식 통합 테스트*: 모듈을 하나씩 통합
	- *하향식 통합 테스트*: 모듈을 하나씩 분리
3. **시스템 테스트(System Test)**
	- 전체 시스템이 정상적으로 작동하는지 확인
	- *기능 테스트*: 시스템의 기능을 테스트
	- *비기능 테스트*: 성능, 안정성, 보안 등 테스트
4. **인수 테스트(Acceptance Test)**
	- 사용자가 요구사항을 만족하는지 확인
	- *알파 테스트*: 개발자가 테스트
	- *베타 테스트*: 사용자가 테스트