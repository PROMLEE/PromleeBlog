## 데이터베이스
> 특정 조직 내 필요한 데이터들의 모임, 공용으로 소유/유지/이용하는 공용 데이터

- 개념적 설계: 독립적인 개념 스키마 모델링
	- *트랜잭션 모델링*
	- E-R 다이어그램
- 논리적 설계: 종속적인 논리 스키마 설계
	- *트랜잭션 인터페이스 설계*
	- *정규화*
	- 논리적 DB 구조로 Mapping
	- 스키마의 평가 및 정제
- 물리적 설계: 목표 DBMS 종속적인 물리적 구조 데이터로 변환
	- *반정규화*
	- 오브젝트, 접근방법, 인덱스, 뷰 용량 설계
	- *트랜젝션 작성*
	- **저장 레코드의 형식, 순서, 접근 경로 설계**

## 데이터 모델 구성 요소
- 구조 (Structure)
	- 데이터의 구조적 특성
	- 데이터의 형식, 길이, 키, 관계 등
- 연산 (Operation)
	- 데이터를 처리하는 작업에 대한 명세
	- 데이터의 삽입, 삭제, 갱신, 검색 등
- 제약 (Constraint)
	- DB에 저장될 수 있는 실제 데이터의 논리적 제약
	- 데이터의 유효성, 일관성, 무결성 등

## 스키마 (Schema)
| 종류 | 설명 |
|---|---|
| 개념 스키마 | 사용자와 DB 관리자 관점 스키마/데이터베이스 전체를 정의<br/>→데이터 개체/관계/제약조건/접근권한/무결성 규칙 명세 |
| 내부 스키마 | DB설계자/개발자 관점의 스키마 / 개념 스키마를 물리적 저장장치에 구현하는 방법을 정의<br/>→ 물리적 구조 / 내부 레코드의 물리적 순서 |
| 외부 스키마 | 사용자 관점의 스키마 / 사용자, 프로그램마다 다양한 형태의 논리적 구조로 존재 |

## E-R 다이어그램 표기법
![240508-174919](/posts/240508-174919.png)

## 관계형 데이터베이스
- 릴레이션(Relation)이라는 표(Table)로 데이터를 표현
- *속성*(Attribute, 열, 필드)과 *튜플*(Tuple, 행, 레코드)로 구성
- *차수*(Degree): 속성의 개수 / *기수*(Cardinality): 튜플의 개수
- *도메인*(Domain): 속성의 원자 값들의 집합(범위)

릴레이션 특징
- 튜플과 속성은 유일하며 순서가 없음
- 튜플을 식별하기 위해 속성의 일부를 key로 사용
- 속성은 Null 값을 가질 수 있으나 *기본 키*에 해당하는 속성은 *Null 값을 가질 수 없음*

## 키(key)
| 종류 | 설명 |
|---|---|
| 후보키 | *유일성*과 *최소성*을 만족하는 키 |
| 기본키 | 후보키 중 선택한 주키, *중복된 값이나 NULL을 가질 수 없다* |
| 대체키 | 후보키 중 기본키를 제외한 나머지 키 |
| 외래키 | 다른 릴레이션의 기본키를 참조하는 속성 / *유일성은 만족하지만 최소성은 만족불가* |
| 슈퍼키 | 릴레이션 내의 속성들의 집합으로 구성된 키 |

## 무결성 (Integrity)
| 종류 | 설명 |
|---|---|
| **개체 무결성** | *기본키*를 구성하는 어떤 속성도 *NULL/중복 값 가질 수 없음* |
| **도메인 / 속성 무결성** | 속성의 값은 정의된 *도메인*에 속해야 한다 |
| **참조 무결성** | *외래키*는 NULL 또는 참조 릴레이션의 기본키 값과 동일하다 |
| 사용자 정의 무결성 | 사용자 정의 무결성 규칙을 만족해야 한다 |
| 데이터 무결성 강화 | 데이터의 정확성, 일관성, 유효성을 보장하기 위한 제약조건 |

## 관계 대수
> 원하는 정보의 검색 과정을 정의하는 *절차적 언어*

1. 순수 관계 연산자
	|기호 | 연산자 | 설명 |
	|---|---|---|
	| σ | Select(선택) | 튜플의 집합에서 조건을 만족하는 튜플을 선택 |
	| π | Project(추출) | 튜플의 집합에서 특정 속성을 선택 |
	| ⋈ | Join(조인) | 두 릴레이션의 공통 속성을 기준으로 조인 |
	| ÷ | Division(나누기) | 두 릴레이션의 관계를 나눗셈 |
2. 일반 집합 연산자
	|기호 | 연산자 | 설명 |
	|---|---|---|
	| ∪ | Union(합집합) | 두 릴레이션의 합집합 |
	| ∩ | Intersection(교집합) | 두 릴레이션의 교집합 |
	| - | Difference(차집합) | 두 릴레이션의 차집합 |
	| x | Cartesian Product(교차곱) | 두 릴레이션의 모든 튜플을 조합 |

## 관계 해석
> 원하는 정보 자체를 정의하는 *비절차적 언어*

1. 논리 연산자
	|기호 | 연산자 | 설명 |
	|---|---|---|
	| ∧ | AND(논리곱) | 두 조건이 모두 참일 때 참 |
	| ∨ | OR(논리합) | 두 조건 중 하나라도 참일 때 참 |
	| ¬ | NOT(부정) | 조건의 반대 |
2. 전량자
	|기호 | 연산자 | 설명 |
	|---|---|---|
	| ∀ | For All(모든) | 모든 튜플에 대해 참 |
	| ∃ | There Exists(존재) | 하나 이상의 튜플에 대해 참 |

## 정규화
> 중복을 최소화하고 데이터의 무결성을 보장하기 위한 과정

- *이상(Anomaly)현상*이 발생하지 않도록 **중복성/종속성을 최소화**하기 위한 작업
- *논리적 설계 단계*에서 수행하며, 속성 수가 적은 테이블로 분할되어 관리가 용이해짐
- 데이터 구조 안정성 최대화 / 데이터 삽입 시 릴레이션 재구성 필요 최소화

- 이상현상 종류
	- 삽입 이상: 릴레이션에 데이터 삽입 시, 원하지 않는 데이터도 함께 삽입
	- 삭제 이상: 릴레이션에서 데이터 삭제 시, 원하지 않는 데이터도 함께 삭제
	- 갱신 이상: 릴레이션에서 데이터 갱신 시, 일부 튜플만 갱신되어 데이터 불일치 발생

## 정규화 과정
1. 제 1 정규형: 모든 *도메인*이 *원자 값*으로만 구성
2. 제 2 정규형: 기본키가 아닌 속성이 기본키에 대한 *완전 함수적 종속 만족* - *부분 함수적 종속 제거*
3. 제 3 정규형: 기본키가 아닌 속성이 기본키에 대해 *이행적 함수적 종속 만족하지 않음*
4. BCNF(Boyce-Codd 정규형): 모든 *결정자*가 *후보키*
5. 제 4 정규형: *다치 종속*이 성립하는 경우 모든 속성이 함수적 종속 관계 만족
6. 제 5 정규형: 모든 *조인 종속*이 후보키를 통해서만 성립

## 데이터 사전 - 시스템 카탈로그
> 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지/관리하는 시스템 테이블

- 데이터베이스에 대한 데이터인 메타데이터 저장
- SQL문을 이용한 내용 검색 기능
- 시스템이 자동으로 생성/유지하며, *일반 사용자가 직접 내용 갱신 불가*

- 데이터 디렉토리(Data Directory): 데이터 사전 접근에 필요한 위치 정보 포함

## 인덱스 (Index)
> 데이터 레코드의 빠른 접근/조회를 이해 별도로 구성한 순서 데이터

데이터베이스에서 테이블 삭제 시 인덱스도 함께 삭제되어야 함(사용자 직접 변경 가능!)
인덱스 생성(CREATE) / 인덱스 삭제(DROP)
종류: 클러스터 / 넌클러스터 / 트리 및 함수 기반 / 비트맵 / 비트맵 조인 / 도메인

## 트랜잭션 (Transaction)



